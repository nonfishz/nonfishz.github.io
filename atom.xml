<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding-Nonfishz</title>
  
  
  <link href="https://codeman.club/atom.xml" rel="self"/>
  
  <link href="https://codeman.club/"/>
  <updated>2022-11-14T02:35:37.642Z</updated>
  <id>https://codeman.club/</id>
  
  <author>
    <name>Nonfishz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes系列（七）—— 实战演练</title>
    <link href="https://codeman.club/null/null/"/>
    <id>https://codeman.club/null/null/</id>
    <published>2022-11-12T11:36:35.000Z</published>
    <updated>2022-11-14T02:35:37.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="玩转Kubernetes（1）"><a href="#玩转Kubernetes（1）" class="headerlink" title="玩转Kubernetes（1）"></a>玩转Kubernetes（1）</h2><span id="more"></span><p>根据本系列前几篇文章的知识，来一个回顾总结和实战，串联一下知识点。</p><h3 id="Kubernetes技术要点回顾"><a href="#Kubernetes技术要点回顾" class="headerlink" title="Kubernetes技术要点回顾"></a>Kubernetes技术要点回顾</h3><p><strong>容器编排</strong>（Container Orchestration），可以说是以前的运维工作在云原生世界的落地实践，本质上还是在集群里调度管理应用程序，只不过管理的主题由人变成了计算机，管理的目标由原生进程变成了容器和镜像</p><p>Kubernetes源自Borg系统。</p><p>Kubernetes的<strong>Master&#x2F;Node</strong>架构是它具有自动化运维能力的关键。下图简略说明它的运行机制：</p><p><img src="/load_images/k8s/7/k8s_7_1.png" alt="image"></p><p>Kubernetes把集群里的计算资源定位节点（Node），其中又划分为 控制面和数据面两类</p><ul><li>控制面是Master节点，负责管理集群和运维监控应用，里面的核心组件是apiserver、controller-manager、etcd、scheduler</li><li>数据面是Worker节点，受Master节点的管控，里面的核心组件是kubelet、kube-proxy、container-runtime</li></ul><p>此外，Kuberneter还支持插件机制，能够灵活扩展各项功能，常用的插件由DNS和Dashboard</p><p>为了更好的管理集群和应用业务，Kubernetes从现实世界中抽象出了许多概念，称为<strong>API对象</strong>，描述这些对象就需要使用<strong>YAML</strong>语言。</p><p>YAML是JSON的超集，但语法更简洁，表现能力更强，更重要的是它以”<strong>声明式</strong>“来表述对象的状态，不涉及具体的操作细节，这样Kubernetes就能够依靠存储在etcd里集群的状态信息，不断地”调控“对象，直至实际状态与期望状态相同，这个过程就是Kubernetes的自动化运维管理。</p><p>Kubernetes最核心的对象是<strong>Pod</strong>，它捆绑了一组存在密切协作关系的容器，容器之间共享网络和存储，在集群里必须一起调度一起运行。通过Pod这个概念，Kubernetes就简化了对容器的管理工作，其他的所有任务都是通过对Pod这个最小单位的再包装来实现的。</p><p>基于”单一职责“和”对象组合“这两个基本原则，学习了比较简单的API对象：Job&#x2F;CronJob和ConfigMap&#x2F;Secret。</p><ul><li>Job&#x2F;CornJob对应的是离线作业，它们逐层包装了Pod，添加了作业控制和定时规则</li><li>ConfigMap&#x2F;Secret对应的是配置信息，需要以环境变量或存储卷的形式注入进Pod，然后进程才能在运行时使用。</li></ul><p>Kubernetes提供了一个客户端工具，<strong>kubectl</strong>，它直接与Master节点的apiserver通信，把YAML文件发送给RESTful接口，从而触发Kubernetes的对象管理工作流程。</p><p>Kubectl命令很多，查看自带文档可以用api-resources、explain，查看对象状态可以用get、describe、logs，操作对象可以用run、apply、exec、delete等等。</p><p>使用YAML描述API对象有固定的格式，必须写的”头字段“是<strong>apiVersion</strong>、<strong>kind</strong>、<strong>metadata</strong>。其他根据具体对象不同，描述不同。</p><h3 id="实战——搭建WordPress网站"><a href="#实战——搭建WordPress网站" class="headerlink" title="实战——搭建WordPress网站"></a>实战——搭建WordPress网站</h3><h4 id="WordPress网站的基本架构"><a href="#WordPress网站的基本架构" class="headerlink" title="WordPress网站的基本架构"></a>WordPress网站的基本架构</h4><p><img src="/load_images/k8s/7/k8s_7_2.png" alt="image"></p><p>Kubernetes系统和Docker系统的区别又在哪里呢？</p><p>关键就在<strong>对应用的封装</strong>和<strong>网络环境</strong>这两点上。</p><p>现在WordPress、MariaDB这两个应用被封装成了Pod，运行所需的环境变量也都被改写成了ConfigMap，同一用“声明式”来管理，比起Shell脚本更容易阅读和版本化管理。</p><p>另外Kubernetes集群在内部维护了一个自己的专用网络，这个网络和外界隔离，需用特殊的“端口转发”方式来传递数据，还需要在集群之外用Nginx反向代理这个地址，这样才能实现内外沟通，对比Docker的直接端口映射，这里略微麻烦了一些。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;玩转Kubernetes（1）&quot;&gt;&lt;a href=&quot;#玩转Kubernetes（1）&quot; class=&quot;headerlink&quot; title=&quot;玩转Kubernetes（1）&quot;&gt;&lt;/a&gt;玩转Kubernetes（1）&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes系列（六）—— ConfigMap/Secret</title>
    <link href="https://codeman.club/k8s/config/"/>
    <id>https://codeman.club/k8s/config/</id>
    <published>2022-11-10T08:17:41.000Z</published>
    <updated>2022-11-11T08:31:08.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConfigMap-x2F-Secret：怎样配置、定制我的应用"><a href="#ConfigMap-x2F-Secret：怎样配置、定制我的应用" class="headerlink" title="ConfigMap&#x2F;Secret：怎样配置、定制我的应用"></a>ConfigMap&#x2F;Secret：怎样配置、定制我的应用</h2><span id="more"></span><p>想让业务顺利的运行，有一个问题不容忽视，那就是应用的配置管理。</p><p>容器中可以选择两种配置文件的方式。第一种是编写Dockerfile，用COPY指令把配置文件打包到镜像里；第二种是在运行时使用docker cp 或者docker run -v，把本机的文件拷贝进容器。</p><p>这两种方法都存在缺陷，第一种方法相当于是在镜像里固定了配置文件，不好修改，不灵活；第二种方法显得有点”笨拙“，不适合在集群中自动化运维管理。</p><p>对于这个问题Kubernetes有自己的解决方案，使用YAML语言来定义API对象，再组合起来实现动态配置。</p><h3 id="ConfigMap-x2F-Secret"><a href="#ConfigMap-x2F-Secret" class="headerlink" title="ConfigMap&#x2F;Secret"></a>ConfigMap&#x2F;Secret</h3><p>应用程序有很多类别的配置信息，从数据安全角度来看可以分为两类：</p><ul><li>一类是明文配置，可以任意查询修改，比如服务端口、运行参数、文件路径等等</li><li>一类是机密配置，设计敏感信息需要保密，不能随便查看，比如密码、密钥、证书等等</li></ul><p>这两类配置信息本质上都是字符串，只是由于安全性的原因，在存放和使用方面有些差异，所以Kubernetes也就定义了两个对象，ConfigMap用来保存明文配置，Secret用来保存机密配置。</p><h4 id="什么是ConfigMap"><a href="#什么是ConfigMap" class="headerlink" title="什么是ConfigMap"></a>什么是ConfigMap</h4><p>使用kubectl create创建一个YAML模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create cm info --dry-run=client -o yaml</span><br></pre></td></tr></table></figure><p>这是后得到的模板是这样子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">info</span></span><br></pre></td></tr></table></figure><p>可以发现这个YAML模板和之前文章提到的Pod、Job等，除了apiVersion、kind、metadata，居然就没有其他了，最重要的字段”spec“去哪了？这是因为ConfigMap存储的是配置数据，是静态的字符串，并不是容器，所以它们就不需要用”spec“字段来说明运行时的”规格“。</p><p>既然ConfigMap要存储数据，那么就需要另外一个含义更明确的字段”data“。</p><p>要生成带有”data“字段的YAML样板，需要再kubectl create后面多加一个参数–from-literal，表示从字面值生成一些数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create cm info --from-literal=k=v --dry-run=client -o yaml &gt;&gt; info.yml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">k:</span> <span class="string">v</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">info</span></span><br></pre></td></tr></table></figure><p>这里可以把YAML修改一下，多添加一些key-value，就得到了一个比较完整的ConfigMap对象：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="string">&#x27;10&#x27;</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="string">&#x27;on&#x27;</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;/etc/systemd&#x27;</span></span><br><span class="line">  <span class="attr">greeting:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">say</span> <span class="string">hello</span> <span class="string">to</span> <span class="string">kubernetes.</span></span><br></pre></td></tr></table></figure><p>创建ConfigMap对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f info.yml</span><br></pre></td></tr></table></figure><p>查看ConfigMap状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cm</span><br><span class="line">kubectl describ cm info</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/6/k8s_6_1.png" alt="image"></p><p>可以看到，ConfigMap的key-value信息就已经存入到了etcd数据库，后续就可以被其他API对象。</p><h4 id="什么是Secret"><a href="#什么是Secret" class="headerlink" title="什么是Secret"></a>什么是Secret</h4><p>在Kubernetes里Secret对象细分很多类，比如：</p><ul><li>访问私有镜像仓库的认证信息</li><li>身份识别的凭证信息</li><li>HTTPS通信的证书和私钥</li><li>一般的机密信息（格式由用户自行解释）</li></ul><p>现在以最后一种示例，创建YAML的格式是kubectl create secret generic：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic user --from-literal=name=root --dry-run=client -o yaml &gt;&gt; user_sec.yml</span><br></pre></td></tr></table></figure><p>得到的YAML样板为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cm9vdA==</span></span><br></pre></td></tr></table></figure><p>可以看到data中的name值为一串”乱码“，而不是命令行输入的root，这就是Secret和ConfigMap的不同之处，不让用户直接看到原始数据，起到一定的保密作用。不过手法非常简单，只是做了Base64的编码，根本算不上真正的加密。所以可以使用Linux小工具”base64“来对数据编码，然后写入YAML文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo -n &quot;123456&quot; | base64 #要加-n，目的是去掉echo字符串产生的隐藏换行符，否则base64编码出来的字符串就是错误的</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果</span></span><br><span class="line">MTIzNDU2</span><br></pre></td></tr></table></figure><p>现在重新编辑Secret的YAML，添加两个新的数据，方式可以是参数–from-literal自动编码，也可以是自己手动编码（base64）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cm9vdA==</span></span><br><span class="line">  <span class="attr">pwd:</span> <span class="string">MTIzNDU2</span></span><br><span class="line">  <span class="attr">db:</span> <span class="string">bXlzcWw=</span></span><br></pre></td></tr></table></figure><p>创建并查看Secret对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f user_sec.yml</span><br><span class="line">kubectl get secret</span><br><span class="line">kubectl describe secret user</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/6/k8s_6_2.png" alt="image"></p><p>因为Secret是保密的，所以使用kubectl  describe不能直接看到内容，只能看到数据的大小。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>现在通过编写YAML文件，创建了ConfigMap和Secret对象，该怎么在Kubernetes里应用它们呢？</p><p>因为ConfigMap和Secret只是一些存储到etcd里的字符串，所以如果想要在运行时产生效果，就必须要以某种方式‘注入”到Pod里，让应用去读取。在这方面的处理上Kubernetes和Docker是一样的，也是两种途径：<strong>环境变量</strong>和<strong>加载文件</strong>。</p><h4 id="以环境变量形式使用ConfigMap-x2F-Secret"><a href="#以环境变量形式使用ConfigMap-x2F-Secret" class="headerlink" title="以环境变量形式使用ConfigMap&#x2F;Secret"></a>以环境变量形式使用ConfigMap&#x2F;Secret</h4><p>Pod中描述容器的字段“<strong>containers</strong>”里有一个“<strong>env</strong>”，它定义了Pod里容器能够看到的环境变量。</p><p>可以使用<strong>valueFrom</strong>字段，从ConfigMap或者Secret对象里获取值，这样就实现了把配置信息以环境变量的形式注入到Pod，也就是配置与应用解耦。</p><p>由于valueFrom在YAML里嵌套的比较深，初次使用最好看一下kubectl explain对它的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain pod.spec.containers.env.valueFrom</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/6/k8s_6_3.png" alt="image"></p><p><strong>valueFrom</strong>字段指定了环境变量的来源，可以是<strong>configMapKeyRef</strong>或者<strong>secretKeyRef</strong>，然后进一步指定ConfigMap&#x2F;Secret的<strong>name</strong>和它里面的<strong>key</strong>，这个name是<strong>API对象的名字</strong>，而不是key-value的名字。</p><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">env-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">COUNT</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">info</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">count</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GREETING</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">info</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">greeting</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">USERNAME</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">secretKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">name</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PASSWORD</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">secretKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">pwd</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busy</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;300&quot;</span>]</span><br></pre></td></tr></table></figure><p>这个Pod的名字是“env-pod”，镜像是“busybox”，执行命令sleep睡眠300秒，这样可以在这段时间进入Pod观察环境变量。</p><p>重点关注“env”字段，里面定义了四个环境变量，COUNT、GREETING、USERNAME、PASSWORD。</p><p>对于明文配置数据，COUNT、GREETING引用的是ConfigMap对象，所使用的字段是<strong>configMapKeyRef</strong>，里面的name是ConfigMap对象的名字info，key字段对应的是info对象里的count和greeting。</p><p>对于机密配置数据，USERNAME、PASSWORD引用的Secret对象，要使用字段<strong>secretKeyRef</strong>，再用name指定Secret对象的名字user，用key字段对应它里面的name和pwd。</p><p>可以对照图片理解：</p><p><img src="/load_images/k8s/6/k8s_6_4.png" alt="image"></p><p>从图中可以清楚的看出Pod与ConfigMap、Secret的”松耦合“关系，它们不是直接嵌套包含，而是使用”KeyRef“字段间接引用对象，这样，同一配置信息就可以在不同的对象之间共享。</p><p>创建Pod，并验证环境变量是否生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f env-pod.yml</span><br><span class="line"></span><br><span class="line">kubectl exec -it env-pod -- sh</span><br><span class="line"></span><br><span class="line">echo $COUNT</span><br><span class="line">echo $GREETING</span><br><span class="line">echo $USERNAME</span><br><span class="line">echo $PASSWORD</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/6/k8s_6_5.png" alt="image"></p><p>从图中可以看到，Pod对象成功组合了ConfigMap和Secret对象。</p><h4 id="如何以Volume的方式使用ConfigMap-x2F-Secret"><a href="#如何以Volume的方式使用ConfigMap-x2F-Secret" class="headerlink" title="如何以Volume的方式使用ConfigMap&#x2F;Secret"></a>如何以Volume的方式使用ConfigMap&#x2F;Secret</h4><p>Kubernetes为Pod定义了一个”Volume“的概念，可以翻译成”存储卷“。如果把Pod理解成一个虚拟机，那么Volume就相当于是虚拟机里的磁盘。</p><p>可以为Pod”挂载（Mount）“多个Volume，里面存放供Pod访问的数据，这种方式有点类似docker run -v，虽然用法复杂了一些，但功能也响应强大一些。</p><p>在Pod里挂载Volume很容易，只需要在<strong>spec</strong>字段增加一个<strong>Volumes</strong>字段，然后再定义卷的名字和引用ConfigMap&#x2F;Secret就可以了。需要注意的是Volume属于Pod，不属于容器，所以它和字段”containers“是同级的，都属于”spec“。</p><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vol-pod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cm-vol</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">info</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sec-vol</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp/cm-items</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cm-vol</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp/sec-times</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">sec-vol</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busy</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;300&quot;</span>]</span><br></pre></td></tr></table></figure><p>从示例中可以看到：</p><ul><li>volumes字段中引入了ConfigMap和Secret，名字分别为cm-vol和sec-vol</li><li>containers字段中使用volumeMoounts挂载了上面引入的两个volume，使用mountPath字段挂载到容器的某个路径下，并使用name字段指定volume的名字</li><li>把volumes和volumeMounts字段写好后，配置信息就可以加载成文件了。</li></ul><p><img src="/load_images/k8s/6/k8s_6_6.png" alt="image"></p><p>从图片中可以看到，挂载Volume的方式和环境变量又不太相同。环境变量是直接引用了ConfigMap&#x2F;Secret，而Volume又多加了一个环节，需要先用Volume引用ConfigMap&#x2F;Secret，然后在容器里挂载Volume。</p><p>这种方式的好处是：以Volume的概念同一抽象了所有的存储，不仅现在支持ConfigMap&#x2F;Secret，以后还能够支持临时卷、持久卷、动态卷、快照卷等许多形式的存储，扩展性非常好。</p><p>创建Pod，并进入Pod查看加载的配置信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f vol-pod.yml</span><br><span class="line">kubectl get pod</span><br><span class="line">kubectk exec -it vol-pod -- sh</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/6/k8s_6_7.png" alt="image"></p><p>可以看到，ConfigMap和Secret都变成了目录形式，而它们里面的key-value变成了一个个文件，而文件名就是Key。</p><p>因为这种形式上的差异，以Volume的方式来使用ConfigMap&#x2F;Secret，就和环境变量不太一样。环境变量用法简单，适合存放简短的字符串，而Volume更适合存放大数据量的配置文件，在Pod里面加载成文件后让应用直接读取使用。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>ConfigMap记录了一些key-value格式的字符串数据，描述字段是data，不是sepc</li><li>Secret，也是使用data保存字符串数据，但它要求数据必须是base64编码，起到一定的保密效果</li><li>Pod的env.valueFrom字段可以引用ConfigMap和Secret，把它们变成应用可以访问的环境变量</li><li>Pod的spec.volumes字段中可以引用ConfigMap和Secret，把它们变成存储卷，然后在spec.containers.volumeMounts字段中加载成文件形式。</li><li>ConfigMap和Secret对存储数据的大小是有限制的，限制为1MB，<a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/#motivation">官方说明</a></li><li>如果已经存在了一些配置文件，可以使用参数–from-file从文件自动创建出ConfigMap或者Secret</li><li>Secret对象默认只会以Base64编码的形式存储在etcd里，而Base64不是加密算法，所以它通常并不是”secret“，不过可以为Kubernetes启用加密功能，实现真正的安全</li><li>Linux里对环境变量的命名有限制，不能使用”-“”.“等特殊字符，所以在创建ConfigMap&#x2F;Secret的时候要留意一下，否则会无法以环境变量的形式注入Pod</li><li>volume这个词也许是来源于早期计算机存储使用的磁带设备，都是一卷一卷的，而mount操作，自然就是把磁带给”挂载“上磁带机了</li><li>可以在volumes.configMap.items字段里用key、path为ConfigMap里的每个key-value精确的指定加载的路径名，也就是给文件改名</li><li>修改了ConfigMap&#x2F;Secret的YAML，并使用kubectl apply命令更新对象，Pod中以环境变量引入的ConfigMap&#x2F;Secret，信息不会发生变动（环境变量是在Pod启动时注入的，所以不会修改，除非Pod重启）；以Volume形式挂载进去的，信息会发生变动。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ConfigMap-x2F-Secret：怎样配置、定制我的应用&quot;&gt;&lt;a href=&quot;#ConfigMap-x2F-Secret：怎样配置、定制我的应用&quot; class=&quot;headerlink&quot; title=&quot;ConfigMap&amp;#x2F;Secret：怎样配置、定制我的应用&quot;&gt;&lt;/a&gt;ConfigMap&amp;#x2F;Secret：怎样配置、定制我的应用&lt;/h2&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://codeman.club/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://codeman.club/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes系列（五）—— Job/CronJob</title>
    <link href="https://codeman.club/k8s/job_cronjob/"/>
    <id>https://codeman.club/k8s/job_cronjob/</id>
    <published>2022-11-09T11:01:19.000Z</published>
    <updated>2022-11-10T14:52:24.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Job-x2F-CronJob：为什么不直接用Pod来处理业务？"><a href="#Job-x2F-CronJob：为什么不直接用Pod来处理业务？" class="headerlink" title="Job&#x2F;CronJob：为什么不直接用Pod来处理业务？"></a>Job&#x2F;CronJob：为什么不直接用Pod来处理业务？</h2><span id="more"></span><h3 id="为什么不直接使用Pod"><a href="#为什么不直接使用Pod" class="headerlink" title="为什么不直接使用Pod"></a>为什么不直接使用Pod</h3><p>Kubernetes使用的是RESTful API，把集群中的各种业务都抽象为HTTP资源对象，那么在这个层次之上，我们就可以使用面向对象的方式来考虑问题。</p><p>为什么用面向对象思想来描述Kubernetes呢，因为Kubernetes使用YAML来描述资源，把业务简化成了一个个对象，内部有属性，外部有联系，也需要互相协作。</p><p>面向对象的设计有许多基本原则，其中有两条比较恰当的描述了Kubernetes对象设计思路，一个是“<strong>单一职责</strong>”，另一个是“<strong>组合优于继承</strong>”。</p><p>“单一职责”的意思是对象应该只专注于做好一件事情，不要贪大求全，保持足够小的粒度才能方便复用和管理。</p><p>“组合优于继承”的意思是应该尽量让对象在运行时产生联系，保持松耦合，而不要用硬编码的方式固定对象的关系。</p><p>应用这两条原则，再来看Kubernetes的资源对象就会很清晰了。因为Pod已经是一个相对完善的对象，专门负责管理容器，那么我们就不应该再“画蛇添足”地盲目为它扩充功能，而是要保持它的独立性，容器之外的功能就需要定义其他的对象，把Pod作为它一个成员“组合”进去。</p><p>这样每种Kubernetes对象就可以只关注自己的业务领域，只做自己最擅长的事情，其他的工作交给其他对象来处理，既不“缺位”也不“越位”，既有分工又有协作，从而以最小成本实现最大收益。</p><h3 id="为什么要走Job-x2F-CronJob"><a href="#为什么要走Job-x2F-CronJob" class="headerlink" title="为什么要走Job&#x2F;CronJob"></a>为什么要走Job&#x2F;CronJob</h3><p>Job和CronJob，它们组合了Job，实现了对离线业务的处理。</p><p>之前文章讲Pod的时候，运行过两个Pod：Nginx和busybox，它们分别代表了Kubernetes里的两大业务。一类是像Nginx这样长时间运行的‘<strong>在线业务</strong>“，另一类是像busybox这样短时间运行的”<strong>离线业务</strong>“。</p><p>”在线业务“类型的应用有很多，比如Nginx、MySQL、Redis等等，一旦运行起来基本上不会停，也就是永远在线。</p><p>”离线业务“类型的应用也不少见，它们一般不直接服务于外部用户，只对内部用户有意义，比如日志分析、数据建模、视频转码等等，虽然计算量很大，但是只会运行一段时间。”离线业务“的特点是<strong>必定会退出</strong>，不会无限地运行下去，所以它的调度策略也就与”在线业务“存在很大不同，需要考虑运行超时、状态检查、失败重试、获取计算结果等管理事项。</p><p>而这些业务特性与容器管理没有必然的联系，如果由Pod来实现就会承担不必要的义务，违反了”单一原则“，所以应该把这部分功能分离到另外一个对象上实现，让这个对象去控制Pod的运行，完成附加的工作。</p><p>”离线业务“也可以分为两种。一种是”<strong>临时任务</strong>“，跑完就完事了，下次有需求了说一声再重新安排；另一种是”<strong>定时任务</strong>“，可以按时按点周期运行，不需要过多干预。</p><p>对应到Kubernetes里，”临时任务“就是API对象Job，”定时任务“就是API对象CronJob，使用这两个对象就能够在Kubernetes里调度管理任意的离线业务了。</p><h3 id="如何使用YAML描述Job"><a href="#如何使用YAML描述Job" class="headerlink" title="如何使用YAML描述Job"></a>如何使用YAML描述Job</h3><p>Job的YAML”文件头“还是那几个必备字段：</p><ul><li>apiVersion，值为batch&#x2F;v1</li><li>kind，值为Job</li><li>metadata里仍然要有name标记名字，也可以用labels添加任意标签</li></ul><p>也可以使用kubectl explain job来看它的字段说明。</p><p>生成Job的YAML样板文件，不能使用kubectl run，因为kubectl run 只能创建Pod，要创建Pod以外的其他API对象，需要使用命令kubectl create，再加上对象的类型名。</p><p>比如用busybox创建一个”echo-job“，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create job echo-job --image=busybox --dry-run=client -o yaml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以上命令会在终端显示yaml格式内容，如果要生成yaml文件，需要 &gt;&gt; filename.yml重定向到文件</span></span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/5/k8s_5_1.png" alt="image"></p><p>稍微修改一下，就有了一个Job对象：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">echo-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">echo-job</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/echo&quot;</span>]</span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>]</span><br></pre></td></tr></table></figure><p>Job的描述和Pod很像，主要区别在”spec“字段里，多了一个template字段，然后又是一个”spec“。</p><p>这里就是刚才所说的面向对象思想，其实就是在Job对象里应用了组合模式，template字段定义了一个”<strong>应用模板</strong>“，里面嵌入了一个Pod，这样Job就可以从这个模板来创建出Pod。</p><p>而这个Pod因为受Job管理控制，不直接和apiserver打交道，也就没必要重复apiVersion等”头字段“，只需要定义好关键的spec，描述清除容器相关的信息就可以了，可以说是一个”无头“的Pod对象。</p><p>可以从下图理解一下：</p><p><img src="/load_images/k8s/5/k8s_5_2.png" alt="image"></p><p>总结来说，这里的Pod工作非常简单，在containers里写好名字和镜像，command执行&#x2F;bin&#x2F;echo，输出”hello world“。</p><p>不过，因为Job业务的特殊性，还需要在Pod的spec里多加一个字段restartPolicy，确定Pod运行失败时的策略，OnFailure是失败原地重启容器，而Never则是不重启容器，让Job去重新调度生成一个新的Pod。</p><h3 id="如何在Kubernetes里操作Job"><a href="#如何在Kubernetes里操作Job" class="headerlink" title="如何在Kubernetes里操作Job"></a>如何在Kubernetes里操作Job</h3><p>现在来创建一个Job对象，运行这个简单的离线作业：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">echo_job.yml</span></span><br></pre></td></tr></table></figure><p>创建之后Kubernetes就会从YAML的模板定义中提取Pod，在Job的控制下运行Pod，可以用kubectl get job、kubectl get pod来查看Job和Pod的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get job</span><br><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/5/k8s_5_3.png" alt="image"></p><p>可以看到，因为Pod被Job管理，它就不会反复重启报错了，而是会显示为Completed表示任务完成，而Job里COMPLETIONS字段也会列出运行成功的作业数量，这里只有一个作业，所以就是1&#x2F;1。</p><p>还可以看到，Pod被自动关联了一个名字，用的是Job的名字（echo-job）再加上一个随机字符串，这当然也是Job管理的功劳，免去了我们手工定义的麻烦，这样我们就可以使用命令kubectk logs来获取Pod的运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs echo-job-4fbpk</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/5/k8s_5_4.png" alt="image"></p><p>到这里，可能会觉得，经过了Job、Pod对容器的两次封装，虽然从概念上很清晰，但好像并没有带来什么实际的好处，和直接跑容器也差不了多少。其实Kubernetes的这套YAML描述对象的框架提供了非常多的灵活性，可以在Job级别、Pod级别添加任意的字段来定制业务，这种优势是简单的容器技术无法相比的。</p><p>这里列出几个控制离线作业的重要字段，其他更详细的信息可以参考Job文档：</p><ul><li><strong>activeDeadlineSeconds</strong>，设置Pod运行的超时时间</li><li><strong>backoffLimit</strong>，设置Pod失败重试次数</li><li><strong>completions</strong>，Job完成需要运行多少个Pod，默认是1个</li><li><strong>parallelism</strong>，与completions相关，表示允许并发运行的Pod数量，避免过多占用资源</li></ul><p>这四个字段并不在template字段下，而是在spec字段下，所有它们是属于Job级别的，用来控制模板里的Pod对象。</p><p>下面在创建一个Job对象，名字叫sleep-job，它随机睡眠一段时间再退出，模拟运行时间较长的作业（比如MapReduce）。Job的参数设置成15秒超时，最多重试2次，总共需要运行完4个Pod，但同一时间最多并发2个Pod：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sleep-job</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">echo-job</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sh</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sleep</span> <span class="string">$(($RANDOM</span> <span class="string">%</span> <span class="number">10</span> <span class="string">+1))</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">done</span></span><br></pre></td></tr></table></figure><p>创建job，并实时观察Pod的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f sleep_job.yml #创建Job</span><br><span class="line">kubectl get pod -w  #实时观察Pod</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/5/k8s_5_5.png" alt="image"></p><p>显然，声明式的Job对象让离线业务的描述变得非常直观，简单的几个字段就可以很好地控制作业的并行度和完成数量，不需要我们去人工监控干预，Kubernetes把这些都自动化实现了。</p><h3 id="如何用YAML描述CronJob"><a href="#如何用YAML描述CronJob" class="headerlink" title="如何用YAML描述CronJob"></a>如何用YAML描述CronJob</h3><h4 id="创建CronJob模板"><a href="#创建CronJob模板" class="headerlink" title="创建CronJob模板"></a>创建CronJob模板</h4><p>CronJob简写cj。kubectl api-resources中可以看到。</p><p>CronJob需要定时运行，所以在命令行里还需要指定参数–schedule。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create cj echo-cj --image=busybox --schedule=&quot;&quot; --dry-run=client -o yaml &gt;&gt; echo_cj.yml</span><br></pre></td></tr></table></figure><p>然后编辑这个模板：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">echo-cj</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&#x27;*/1 * * * *&#x27;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">echo-cj</span></span><br><span class="line">            <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;/bin/echo&quot;</span>]</span><br><span class="line">            <span class="attr">args:</span> [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>]</span><br></pre></td></tr></table></figure><p>还是重点关注spec字段，会发现居然连续有三个spec嵌套层次：</p><ul><li>第一个spec是CronJob自己的对象规格</li><li>第二个spec从属于”JobTemplate“，它定义了一个Job对象</li><li>第三个spec从属于”Template“，它定义了Job里运行的Pod</li></ul><p>所以CronJob其实是又组合了Job而生成的新对象：</p><p><img src="/load_images/k8s/5/k8s_5_6.png" alt="image"></p><p>除了定义Job对象的”jobTemplate“字段之外，CronJob还有一个新字段就是”schedule“，用来定义任务周期运行的规则。使用的是标准的Cron语法，指定分钟、小时、天、月、周，和Linux的crontab一样。这里是每分钟运行一次。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f echo_cj.yml #创建CronJob</span><br><span class="line">kubectl get cj #查看cj状态</span><br><span class="line">kubectl get pod #查看对应pod状态</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/5/k8s_5_7.png" alt="image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>Pod是Kubernetes的最小调度单元，为了保持它的独立性，不应该向它添加多余的功能</p></li><li><p>Kubernetes为离线业务提供了Job和CronJob两种API对象，分别处理”临时任务“和”定时任务“</p></li><li><p>Job的关键字段是spec.template，里面定义了用来运行业务的Pod模板，其他的重要字段有completions、parallelism等</p></li><li><p>CronJob的关键字段是sepc.jobTemplate和spec.schedule，分别定义了Job模板和定时运行的规则</p></li><li><p>Job&#x2F;CronJob的apiVersion字段是batch&#x2F;v1，表示它们不属于核心对象组（core group），而是批处理对象组（batch group）</p></li><li><p>单词Cron来源于希腊语，即Chronos，意思是”时间“</p></li><li><p>Job在运行结束后不会立即删除，这是为了方便获取计算结果，如果积累过多的已完成Job也会消耗系统资源，可以使用字段”ttlSecondsAfterFinished“设置一个保留的时限。</p></li><li><p>出于节约资源考虑，CronJob不会无限保留已经运行的Job，它默认只保留3个最近的执行结果，但可以用字段”successfulJobsHistoryLimit“改变。</p></li><li><p>网站<a href="https://crontab.guru/">https://crontab.guru/</a> 可以很直观的表达Cron时间设置表达式的含义</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Job-x2F-CronJob：为什么不直接用Pod来处理业务？&quot;&gt;&lt;a href=&quot;#Job-x2F-CronJob：为什么不直接用Pod来处理业务？&quot; class=&quot;headerlink&quot; title=&quot;Job&amp;#x2F;CronJob：为什么不直接用Pod来处理业务？&quot;&gt;&lt;/a&gt;Job&amp;#x2F;CronJob：为什么不直接用Pod来处理业务？&lt;/h2&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://codeman.club/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://codeman.club/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes系列（四）—— Pod</title>
    <link href="https://codeman.club/k8s/pod/"/>
    <id>https://codeman.club/k8s/pod/</id>
    <published>2022-11-07T14:38:36.000Z</published>
    <updated>2022-11-10T14:52:11.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pod：Kubernetes最核心的概念"><a href="#Pod：Kubernetes最核心的概念" class="headerlink" title="Pod：Kubernetes最核心的概念"></a>Pod：Kubernetes最核心的概念</h2><span id="more"></span><h3 id="为什么要有Pod"><a href="#为什么要有Pod" class="headerlink" title="为什么要有Pod"></a>为什么要有Pod</h3><p><img src="/load_images/k8s/4/k8s_4_1.png" alt="k8s_4_1"></p><p>Pod原意是“豌豆荚”，后来又延伸出“舱室”“太空舱”等含义，图片中，形象的来说Pod就是包含了多组件、成员的一种结构。</p><p>容器技术，让进程在一个“沙盒”环境里运行，具有良好的隔离性，对应用时一个非常好的封装。</p><p>不过，当容器技术进入到现实的生产环境中时，这种隔离性就带来了一些麻烦。因为很少有应用时完全独立运行的，经常需要几个进程互相协作才能完成任务。</p><p>那么把多个应用都放到一个容器里运行可不可以呢？</p><p>当然可以，但这并不是一种好做法。因为容器的理念是对应用的独立封装，它里面就应该是一个进程、一个应用，如果里面有多个应用，不仅违背了容器的初衷，也会让容器更难以管理。</p><p><strong>为了解决这样多应用联合的问题，同时还不破坏容器的隔离，就需要再容器外面再建立一个“收纳舱”</strong>，让多个容器保持相对独立，又能够小范围共享网络、存储等资源，而且永远是“绑在一起”的状态。</p><p>所以，Pod的概念也就呼之欲出了，容器正式“豆荚”里那些小小的“豌豆”，可以在Pod的YAML里看到，“spec.containers”字段其实是一个数组，里面允许定义多个容器。</p><h3 id="为什么Pod是Kubernetes的核心对象"><a href="#为什么Pod是Kubernetes的核心对象" class="headerlink" title="为什么Pod是Kubernetes的核心对象"></a>为什么Pod是Kubernetes的核心对象</h3><p>因为Pod是对容器的“打包”，里面的容器是一个整体，总是能够一起调度、一起运行，绝对不会出现分离的情况，而且Pod属于Kubernetes，可以在不触碰下层容器的情况下任意定制修改。所以有了Pod这个抽象概念，Kubernetes在集群级别上管理应用就会“得心应手”了。</p><p>Kubernetes让Pod去编排处理容器，然后把Pod作为应用调度部署的<strong>最小单位</strong>，Pod也因此成为了Kubernetes世界里的“原子”（当然这个原子内部是有结构的，不是铁板一块），基于Pod就可以构建出更多更复杂的业务形态了。</p><p><img src="/load_images/k8s/4/k8s_4_2.png" alt="k8s_4_2"></p><p>从图中可以看出，所有的Kubernetes资源都直接或者间接的依附在Pod之上，所有的Kubernetes功能都必须通过Pod来实现，所以Pod理所当然地成为了Kubernetes的核心对象。</p><h3 id="如何用YAML描述Pod"><a href="#如何用YAML描述Pod" class="headerlink" title="如何用YAML描述Pod"></a>如何用YAML描述Pod</h3><p>我们始终可以使用<strong>kubectl explain</strong>来查看任意字段的详细说明。</p><p>Pod是API对象，所以它必然也有apiVersion、kind、metadata、spec这四个基本组成部分。</p><p>apiVersion和kind这两个字段很简单，对于Pod来说分别是固定值v1和Pod。</p><p>而一般来说，“metadata”里应该有name和labels这两个字段。在使用Docker创建容器的时候，可以不给容器起名字，但在Kubernetes里，Pod必须要有一个名字，这也是Kubernetes里所有资源对象的一个约定。name只是一个基本的标识，信息有限，所以labels字段就派上了用处。它可以添加任意数量的key-value，给Pod贴上归类的标签，结合那么就更方便识别和管理了。</p><p>比如，可以根据运行环境，使用标签env: dev&#x2F;test&#x2F;prod，或者根据所在的数据中心，使用标签region: north&#x2F;south，还可以根据应用在系统中的层次，使用tier: front&#x2F;middle&#x2F;back等等。</p><p>下面这段YAML代码就描述了一个简单的Pod，名字是“busy-pod”，再附加上一些标签：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busy-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">nonfishz</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">region:</span> <span class="string">north</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">back</span></span><br></pre></td></tr></table></figure><p>“metadata”一般协商name和labels就足够了，而“spec”字段由于需要管理、维护Pod这个Kubernetes的基本调度单元，里面有非常多的关键信息，现在介绍最重要的“containers”。</p><p>“containers”是一个数组，里面每一个元素又是一个container对象，也就是容器。</p><p>和Pod一样，container对象也必须要有一个name表示名字，然后当然还要有一个image字段来说明它使用的镜像，这两个字段必须要有，否则Kubernetes会报告数据验证错误。</p><p>container对象的字段：</p><ul><li><strong>ports</strong>：列出容器对外暴露的端口，和Docker的-p参数有点像</li><li><strong>imagePullPolicy</strong>：指定镜像的拉取策略，可以是Always&#x2F;Never&#x2F;IfNotPresent，一般默认是IfNotPresent（Defaults to Always if :latest tag is specified。 只有lastest才是always）</li><li><strong>env</strong>：定义container的环境变量，和Dockerfile里的ENV指令有点类似，但它是运行时指定的，更加灵活可配置</li><li><strong>command</strong>：定义容器启动时要执行的命令，相当于Dockerfile里的ENTRYPOINT指令。</li><li><strong>args</strong>：它是command运行时的参数，相当于Dockerfile里的CMD指令，这个命令和Docker的含义不同，要特别注意</li></ul><p>现在来编写“busy-pod”的spec部分，添加env、command、args等字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busy</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">os</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;ubuntu&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">debug</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;on&quot;</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/bin/echo</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$(os), $(debug)&quot;</span></span><br></pre></td></tr></table></figure><p>这里为Pod指定使用镜像busybox:latest，拉取策略是IfNotPresent，然后定义了os和debug两个环境变量，启动命令是&#x2F;bin&#x2F;echo，参数里输出刚才定义的环境变量。</p><p>把这份YAML文件和Docker命令对比一下，可以看出，YAML在spec.containers字段里用“声明式”把容器的运行状态描述的非常清晰准确，要比docker run那长长的命令行要整洁的多，对人、对机器都非常友好。</p><h3 id="如何使用kubectl操作Pod"><a href="#如何使用kubectl操作Pod" class="headerlink" title="如何使用kubectl操作Pod"></a>如何使用kubectl操作Pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f busy-pod.yml</span><br><span class="line">kubectl delete -f busy-pod.yml</span><br></pre></td></tr></table></figure><p>因为在YAML里定义了“name”字段，所以也可以再删除的时候直接指定名字来删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod busy-pod</span><br></pre></td></tr></table></figure><p>和Docker不一样，Kubernetes的Pod不会在前台运行，只能在后台（相当于默认使用了参数-d），所以输出信息不能直接看到。我们可以用命令kubectl logs，它会把Pod的标准输出流信息展示给我们看，在这里就会显示出预设的两个环境变量值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs busy-pod</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/4/k8s_4_3.png" alt="image"></p><p>查看Pod列表和运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/4/k8s_4_4.png" alt="image"></p><p>从图片中发现这个Pod运行有点不正常，状态是“CrashLoopBackOff”，那么可以使用命令kubectl describe来检查它的详细状态，在调试排错时很有用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod busy-pod</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/4/k8s_4_5.png" alt="image"></p><p>通常只需要关注末尾的“Events”部分，它显示的是Pod运行过程中的一些关键节点事件。</p><p>对于这个busy-pod，因为它只执行了一条echo命令就退出了，而Kubernetes默认会重启Pod，所以就会进入一个反复停止 - 启动的循环错误状态。</p><p>Kubernetes里运行的应用大部分都是不会主动退出的服务，我们可以把这个busy-pod删掉，创建一个ngx-pod.yml，启动一个Nginx服务，这才是大多数Pod的工作方式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ngx-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">nonfishz</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ngx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f ngx-pod.yml</span><br><span class="line"></span><br><span class="line">kubectl get pod #可以看到ngix-pod处于Running状态</span><br><span class="line"></span><br><span class="line">kubectl log ngx-pod #可以查看Nginx的运行日志</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/4/k8s_4_6.png" alt="image"></p><p>kubectl cp 可以把本地文件拷贝进Pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello Pod&quot; &gt;&gt; tmp.txt</span><br><span class="line">kubectl cp tmp.txt ngx-pod:/tmp</span><br></pre></td></tr></table></figure><p>kubectl exec进入Pod内部执行Shell命令，需要再Pod后面加上–，把kubectl的命令和Shell命令分隔开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it ngx-pod -- sh</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/4/k8s_4_7.png" alt="image"></p><p>虽然Pod是Kubernetes的核心概念，非常重要，但事实上在Kubernetes里通常并不会直接创建Pod，因为它支队容器做了简单的包装，比较脆弱，离复杂的业务需求还有些距离，需要Job、CronJob、Deployment等其他对象增添更多的功能才能投入生产使用。</p><p>Pod内部有一个名为infra的容器，它实际上代表了Pod，维护着Pod内多容器共享的主机名、网络和存储。infra容器的镜像叫“pause”，非常小，只有不到500KB。</p><p>metadata里的标签不能任意写，必须要符合域名规范（FQDN）。</p><p>对于确实不需要重启的Pod，可以配置字段“restartPolicy: Never”。</p><p>kubectl get pod命令结果中的“READY”栏显示的是Pod内部的容器状态，格式是“x&#x2F;y”，表示Pod里总共定义了y个容器，其中x个是正常的（ready）。</p><p>准确的说，kubectl cp 、kubectl exec操作的应该是Pod里面的容器，需要用-c参数指定容器名，不过因为大多数Pod里只有一个容器，所以就省略了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Pod：Kubernetes最核心的概念&quot;&gt;&lt;a href=&quot;#Pod：Kubernetes最核心的概念&quot; class=&quot;headerlink&quot; title=&quot;Pod：Kubernetes最核心的概念&quot;&gt;&lt;/a&gt;Pod：Kubernetes最核心的概念&lt;/h2&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://codeman.club/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://codeman.club/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes系列（三）—— YAML</title>
    <link href="https://codeman.club/k8s/yaml/"/>
    <id>https://codeman.club/k8s/yaml/</id>
    <published>2022-11-07T07:36:23.000Z</published>
    <updated>2022-11-10T14:52:00.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="YAML：Kubernetes世界里的通用语"><a href="#YAML：Kubernetes世界里的通用语" class="headerlink" title="YAML：Kubernetes世界里的通用语"></a>YAML：Kubernetes世界里的通用语</h2><span id="more"></span><h3 id="声明式与命令式"><a href="#声明式与命令式" class="headerlink" title="声明式与命令式"></a>声明式与命令式</h3><p>Kubernetes使用的YAML语言有一个非常关键的特性，叫“声明式”（Declarative），对应的有另外一个词：“命令式”（Imperative）。</p><p>大多数编程语言属于命令式，特点是交互性强，注重顺序和过程，你必须要告诉计算机每步该做什么，所有的步骤都列清楚，这样程序才能一步一步走下去。</p><p>声明式与命令式相反，它不关心具体过程，更注重结果。不需要“教”计算机该怎么做，只告诉它一个目标状态，它自己就会想办法去完成任务，相比起来自动化、智能化程度更高。</p><h3 id="什么是YAML"><a href="#什么是YAML" class="headerlink" title="什么是YAML"></a>什么是YAML</h3><p>创建于2001年，比XML晚了3年。</p><p>YAML<a href="https://yaml.org/">官网</a></p><p>阮一峰<a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML</a> 具体用法可参考这一片文章</p><p>YAML是JSON的超集，支持证书、浮点数、布尔、字符串、数组和对象等数据类型。任何合法的JSON文档也都是YAML文档。</p><h3 id="什么是API对象"><a href="#什么是API对象" class="headerlink" title="什么是API对象"></a>什么是API对象</h3><p>作为一个集群操作系统，Kubernetes归纳总结了Google多年的经验，在理论层面抽象出了很多个概念，用来描述系统的管理运维工作，这些概念就叫做“API对象”。来源于apiserver。</p><p>都有哪些API对象呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前Kubernetes版本支持的所有对象</span></span><br><span class="line">kubectl api-resources </span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/3/k8s_3_1.png" alt="image"></p><p>NAME一栏，就是对象的名字。SHORTNAMES是简写，在使用kubectl命令的时候可以使用</p><p>在使用kubectl命令的时候，可以加上一个参数–v&#x3D;9，它会显示出详细的命令执行过程，清楚地看到发出的HTTP请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod --v=9</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/3/k8s_3_2.png" alt="image"></p><p>从图中可以看到，kubectl客户端等价于调用了curl，向8443端口发送了HTTP GET请求，URL是&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods。</p><p>这些API对象，全面地描述了集群的节点、应用、配置、服务、账号等等信息，apiserver会把它们都存储在数据库etcd里，然后kubelet、scheduler、controller-manager等组件通过apiserver来操作它们，就在API对象这个抽象层次实现了对整个集群的管理。</p><h3 id="如何描述API对象"><a href="#如何描述API对象" class="headerlink" title="如何描述API对象"></a>如何描述API对象</h3><p>以YAML语言，使用“声明式”在Kubernetes里描述并创建API对象。</p><p>使用kubectl run运行Nginx，这是命令式的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run ngx --image=nginx:alpine</span><br></pre></td></tr></table></figure><p>把它改成声明式的YAML，说清楚想要的Nginx应用是什么样子，也就是“目标状态”，让Kubernetes自己去决定如何拉取镜像运行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ngx-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">nonfishz</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ngx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>这是一个Pod，使用nginx:alpine镜像创建一个容器，开放端口80，其他部分则是Kubernetes对API对象强制的格式要求了。</p><p>因为API对象采用标准的HTTP协议，为方便理解，我们可以借鉴一下HTTP的报文格式，把API对象的描述分成“header”和“body”两部分。</p><p>“header”包含API对象的基本信息，有三个字段：apiVersion、kind、metadata。</p><ul><li>apiVersion表示操作这种资源的API版本号，由于Kubernetes的迭代速度很快，不同的版本创建的对象会有差异，为了区分这些版本就需要使用apiVersion这个字段，比如v1、v1alpha1、v1beta1等等。</li><li>kind表示资源对象的类型，这个应该很好理解，比如Pod、Node、Job、Service等等。</li><li>metadata这个字段顾名思义，表示的是资源的一些“元信息”，也就是用来标记对象，方便Kubernetes管理的一些信息。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ngx-pod</span> <span class="comment">#给Pod起了个名字叫ngx-pod</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#给Pod“贴”上了一些便于查找的标签，分别是env和owner</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">nonfishz</span></span><br></pre></td></tr></table></figure><p>和HTTP协议一样，“header”里的apiVersion、kind、metadata这三个字段是任何对象都必须有的，而“body”部分则会与对象特定相关，每种对象会有不同的规格定义，在YAML里表现为spec字段（specification），表示我们对对象的“期望状态”（desired status）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ngx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>这份YAML文档完整的描述了一个类型是Pod的API对象，要求使用v1版本的API接口去管理，其他更具体的名字、标签、状态等细节都记录在了metadata和spec字段等里。</p><p>创建、删除对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f ngx-pod.yml [--v=9]</span><br><span class="line">kubectl delete -f ngx-pod.yml [--v=9]</span><br></pre></td></tr></table></figure><p>Kubernetes收到这份“声明式”的数据，再根据HTTP请求里的POST&#x2F;DELETE等方法，就会自动操作这个资源对象，至于对象在哪个节点上、怎么创建、怎么删除完全不用我们操心。</p><h3 id="如何编写YAML"><a href="#如何编写YAML" class="headerlink" title="如何编写YAML"></a>如何编写YAML</h3><p><a href="https://kubernetes.io/docs/reference/kubernetes-api/">官方文档</a> API对象的所有字段都可以在里面找到。</p><h4 id="第一个技巧"><a href="#第一个技巧" class="headerlink" title="第一个技巧"></a>第一个技巧</h4><p>kubectl api-resources命令，会显示出资源对象响应的API版本和类型。</p><h4 id="第二个技巧"><a href="#第二个技巧" class="headerlink" title="第二个技巧"></a>第二个技巧</h4><p>kubectl explain，相当于Kubernetes自带的API文档，会给出对象字段的详细说明，这样就不必去网上查找了。</p><p>比如想看Pod里的字段该怎么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain pod</span><br><span class="line">kubectl explain pod.metadata</span><br><span class="line">kubectl explain pod.spec</span><br><span class="line">kubectl explain pod.spec.containers</span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/3/k8s_3_3.png" alt="image"></p><h4 id="第三个技巧"><a href="#第三个技巧" class="headerlink" title="第三个技巧"></a>第三个技巧</h4><p>kubectl两个特殊的参数 –dry-run&#x3D;client和-o yaml，前者是空运行，后者是生成YAML格式，结合起来使用就会让kubectl不会有实际的创建动作，而只生成YAML文件。</p><p>例如，生成一个Pod的YAML样板示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl run ngx --image=nginx:alpine --dry-run=client -o yaml</span><br><span class="line">#注：以上命令只会在终端输出yaml内容，如果需要生成文件，需要重定向到文件中 &gt;&gt; filename.yml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">ngx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ngx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ngx</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>接下来要做的就是查阅文档，添加或者删除字段来定制这个YAML。</p><p>这个小技巧还可以再进化一下，把这段参数定义成Shell变量，用起来更方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export out=&quot;--dry-run=client -o yaml&quot;</span><br><span class="line">kubectl run ngx --image=nginx:alpine $out</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;YAML：Kubernetes世界里的通用语&quot;&gt;&lt;a href=&quot;#YAML：Kubernetes世界里的通用语&quot; class=&quot;headerlink&quot; title=&quot;YAML：Kubernetes世界里的通用语&quot;&gt;&lt;/a&gt;YAML：Kubernetes世界里的通用语&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes(二) —— 工作机制</title>
    <link href="https://codeman.club/k8s/core/"/>
    <id>https://codeman.club/k8s/core/</id>
    <published>2022-11-07T02:53:05.000Z</published>
    <updated>2022-11-10T14:51:40.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes工作机制"><a href="#Kubernetes工作机制" class="headerlink" title="Kubernetes工作机制"></a>Kubernetes工作机制</h2><span id="more"></span><h3 id="Kubernetes基本架构图"><a href="#Kubernetes基本架构图" class="headerlink" title="Kubernetes基本架构图"></a>Kubernetes基本架构图</h3><p><img src="/load_images/k8s/2/k8s_2_1.png" alt="image"></p><p>Kubernetes采用了现在流行的”控制面&#x2F;数据面“（Control Plane &#x2F; Data Plane）架构，集群里的计算机被称为”节点“（Node），可以是实机也可以是虚机，少量的节点用作控制面来执行集群的管理维护工作，其他的大部分节点都被划归数据面，用来跑业务应用。</p><p>控制面节点在Kubernetes中叫做Master Node，一般简称为Master，它是整个集群里最重要的部分，可以说是Kubernetes的大脑和心脏。</p><p>数据面的节点叫做Worker Node，一般旧简称为Worker或者Node，相当于Kubernetes的手和脚，在Master的指挥下干活。</p><p>Node的数量非常多，构成了一个资源池，Kubernetes就在这个池里分配资源，调度应用。因为资源被”池化了，所以管理也就变的比较简单，可以在集群中任意添加或者删除节点。</p><p>kubectl是Kubernetes的客户端工具，用来操作Kubernetes，但它位于集群之外，理论上不属于集群。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br><span class="line"></span><br><span class="line">NAME       STATUS   ROLES                  AGE     VERSION</span><br><span class="line">minikube   Ready    control-plane,master   2d12h   v1.23.3</span><br></pre></td></tr></table></figure><p>可以看到当前的minikube集群里只有一个Master，那Node怎么不见了？</p><p>这是因为Master和Node的划分不是绝对的。当集群规模较小，工作负载较少的时候，Master也可以承担Node的工作，就像我们搭建的minikube环境，它就只有一个节点，这个节点既是Master又是Node。</p><h3 id="节点的内部结构"><a href="#节点的内部结构" class="headerlink" title="节点的内部结构"></a>节点的内部结构</h3><p>Kubernetes的节点内部也具有复杂的结构，是由很多模块构成的，这些模块又可以分成组件（Component）和插件（Addon）两类。</p><p>组件实现了Kubernetes的核心功能特性，没有这些组件Kubernetes就无法启动。</p><p>插件是Kubernetes的一些附加功能，属于“锦上添花”，不安装也不影响Kubernetes的正常运行。</p><h4 id="Master里的组件有哪些"><a href="#Master里的组件有哪些" class="headerlink" title="Master里的组件有哪些"></a>Master里的组件有哪些</h4><p>Master里有4个组件，分别是apiserver、etcd、scheduler、controller-manager。</p><p><img src="/load_images/k8s/2/k8s_2_2.png" alt="image"></p><p>apiserver是Master节点，同时也是整个Kubernetes系统的唯一入口，它对外公开了一系列的RESTful API，并且加上了验证、授权等功能，所有其他组件都只能和它直接通信，可以说是Kubernetes里的联络员。</p><p>etcd是一个高可用的分布式key-value数据库，用来持久化存储系统里的各种资源对象和状态，相当于Kubernetes里的配置管理员。注意它只与apiserver有直接联系，也就是说任何组件想要读写etcd里的数据都必须经过apiserver。</p><p>scheduler负责容器的编排工作，检查节点的资源状态，把Pod调度到最合适的节点上运行，相当于部署人员。因为节点状态和Pod信息都存储在etcd里，所以scheduker必须通过apiserver才能获得。</p><p>controller-manager负责维护容器和节点等资源的状态，实现故障检测、服务迁移、应用伸缩等功能，相当于监控运维人员、同样地，它也必须通过apiserver获得存储在etcd里的信息，才能够实现对资源的各种操作。</p><p>这四个组件也都被容器化了，运行在集群的Pod里，可以用kubectl开查看它们的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kube-system</span><br><span class="line"></span><br><span class="line">NAME                               READY   STATUS    RESTARTS      AGE</span><br><span class="line">coredns-65c54cc984-7xz52           1/1     Running   0             2d13h</span><br><span class="line">etcd-minikube                      1/1     Running   0             2d13h</span><br><span class="line">kube-apiserver-minikube            1/1     Running   0             2d13h</span><br><span class="line">kube-controller-manager-minikube   1/1     Running   0             2d13h</span><br><span class="line">kube-proxy-zkrqm                   1/1     Running   0             2d13h</span><br><span class="line">kube-scheduler-minikube            1/1     Running   0             2d13h</span><br><span class="line">storage-provisioner                1/1     Running   4 (22h ago)   2d13h</span><br></pre></td></tr></table></figure><p>注意-n kube-system参数，表示检查kube-system名字空间里的Pod。</p><h4 id="Node里的组件"><a href="#Node里的组件" class="headerlink" title="Node里的组件"></a>Node里的组件</h4><p>Master里的apiserver、scheduler等组件需要获取节点的各种信息才能够做出管理决策，那这些信息该怎么来呢？</p><p>这就需要Node里的3个组件，kubulet、kube-proxy、container-runtime。</p><p><img src="/source/load_images/k8s/2/k8s_2_3.jpeg" alt="k8s_2_3"></p><p>kubelet是Node的代理，负责管理Node相关的绝大部分操作，Node上只有它能够与apiserver通信，实现状态报告、命令下发、启停容器等功能，相当于Node上的一个“小管家”。</p><p>kube-proxy的作用有点特别，它是Node的网络代理，只负责管理容器的网络通信，简单来说就是为Pod转发TCP&#x2F;UDP数据包，相当于是专职的“小邮差”。</p><p>container-runtime，它是容器和镜像的实际使用者，在kubelet的指挥下创建容器，管理Pod的生命周期，是真正干活的苦力。</p><p>注意：因为Kubernetes的定位是容器编排平台，所以它没有限定container-runtime必须是docker，完全可以替换成任何符合标准的其他容器运行时，例如containerd、CRI-O等。</p><p>这三个组件只有kube-proxy被容器化了，而kubelet因为必须要管理整个节点，容器化会限制它的能力，所以它必须在container-runtime之外运行。</p><p>使用minikube ssh登录节点后，可以使用docker ps查看kube-proxy：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minikube ssh</span><br><span class="line">docker ps | grep kube-proxy</span><br></pre></td></tr></table></figure><p><img src="/source/load_images/k8s/2/k8s_2_4.jpeg" alt="image"></p><p>而kubelet用docker ps是找不到的，需要用操作系统的ps命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep kubelet</span><br></pre></td></tr></table></figure><p>现在再把Node里的组件和Master里的组件放在一起来看，就能够明白Kubernetes的大致流程了：</p><ul><li>每个Node上的kubelet会定期向apiserver上报节点的状态，apiserver再存到etcd里。</li><li>每个Node上的kube-proxy实现了TCP&#x2F;UDP反向代理，让容器对外提供稳定的服务。</li><li>scheduler通过apiserver得到当前节点的状态，调度Pod，然后apiserver下发命令个Node的kubelet，kubelet调用container-runtime启动容器。</li><li>controller-manager也通过apiserver得到实时的节点状态，监控可能得异常情况，再使用相应的手段去调节恢复。</li></ul><p><img src="/load_images/k8s/2/k8s_2_5.png" alt="k8s_2_5"></p><h4 id="插件（Addons）有哪些"><a href="#插件（Addons）有哪些" class="headerlink" title="插件（Addons）有哪些"></a>插件（Addons）有哪些</h4><p>只要服务器节点上运行了apiserver、scheduler、kubelet、kube-proxy、container-runtime等组件，就可以说是一个功能齐全的Kubernetes集群了。</p><p>由于Kubernetes本身设计的非常灵活，所以就有大量的插件用来扩展、增强它对应用和集群的管理能力。</p><p>minikube也支持很多插件，使用命令minikube addons list就可以查看插件列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube addons list</span><br></pre></td></tr></table></figure><img src="/load_images/k8s/2/k8s_2_6.png" alt="image" style="zoom:50%;" /><p>有比较重要的两个插件DNS和Dashboard。</p><p>DNS在Kubernetes集群里实现了域名解析服务，能够让我们以域名而不是IP地址的方式来互相通信，是服务发现和负载均衡的基础。由于它对微服务、服务网格等架构至关重要，所以基本上是Kubernetes的必备插件。</p><p>Dashboard仪表盘，为Kubernetes提供了一个图形化的操作界面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minikube dashboard</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以在默认浏览器打开Dashboard页面，而且还支持中文</span></span><br></pre></td></tr></table></figure><p><img src="/load_images/k8s/2/k8s_2_7.png" alt="k8s_2_7"></p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><img src="/load_images/k8s/2/k8s_2_8.png" alt="image"  /><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>为确保控制面的高可用，Kubernetes集群里都会部署多个Master节点，数量一般会是奇数（3&#x2F;5&#x2F;7），这是有etcd的特性决定的。</p><p>controller-manager是多个controller的集合体，每一个controller负责一种控制循环（如node controller、namespace controller），为了简化被合并在一个进程里面执行。</p><p>minikuber的Dashboard只允许在本机运行的浏览器访问，不过也可以给它配置Nginx反向代理。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Kubernetes工作机制&quot;&gt;&lt;a href=&quot;#Kubernetes工作机制&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes工作机制&quot;&gt;&lt;/a&gt;Kubernetes工作机制&lt;/h2&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://codeman.club/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://codeman.club/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes系列（一）—— 如何在本机搭建小巧完备的kubernetes环境</title>
    <link href="https://codeman.club/k8s/minikube/"/>
    <id>https://codeman.club/k8s/minikube/</id>
    <published>2022-11-04T17:13:58.000Z</published>
    <updated>2022-11-10T14:49:07.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><span id="more"></span><p><a href="https://kubernetes.io/zh/docs/tasks/tools/">tools</a></p><h3 id="kind"><a href="#kind" class="headerlink" title="kind"></a>kind</h3><ul><li>基于Docker，意思是”Kubernetes in Docker“。它功能少，用法简单，因此运行速度快，容易上手。</li><li>缺少很多Kubernetes标准功能，例如仪表盘、网络插件，也很难定制化。</li><li>适合做快速开发测试，不太适合学习研究。</li></ul><h3 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h3><ul><li>”迷你“版本的Kubernetes，紧跟Kubernetes版本更新，同时也兼容较旧的版本（最多只到之前的6个小版本）。</li><li>小而美，可执行文件仅有不到100M，运行镜像也不过1GB，这么小的空间却集成了Kubernets的绝大多数功能。</li><li>不仅有核心的容器编排功能，还有丰富的插件，例如Dashboard、GPU、Ingress、Istio、Kong、Registry等。</li></ul><h4 id="如何搭建minikube环境"><a href="#如何搭建minikube环境" class="headerlink" title="如何搭建minikube环境"></a>如何搭建minikube环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Intel x86_64</span> </span><br><span class="line">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Apple arm64</span></span><br><span class="line">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64</span><br><span class="line"></span><br><span class="line">sudo install minikube /usr/local/bin/</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看版本号，验证是否安装成功</span></span><br><span class="line">minikube version</span><br></pre></td></tr></table></figure><h4 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h4><p>minikube只能搭建Kubernete环境，要操作Kubernets，还需要专门的客户端工具kubectl</p><p>类似于docker，kubectl也是一个命令行工具，作用也类似，与Kubernets后台服务通信，把命令转发给Kubernets，实现容器和集群的管理功能</p><p>kubectl是一个与Kubernets、minikube彼此独立的项目，所以不包含在minikube里，但minikube提供了安装它的简化方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minikube kubectl</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该命令会把与当前Kubernets版本匹配的kubectl下载下来，存放在内部目录（例如.minikube/cache/linux/arm64/v1.23.3）</span></span><br></pre></td></tr></table></figure><p>所以，在minikube环境里，会用到两个客户端：minikube管理Kubernets集群环境，kubectl操作实际的kubernetes功能，和Docker比起来有点复杂。</p><img src="/load_images/k8s/1/k8s_1_1.png" alt="image-20221105013324401" style="zoom:50%;" /><h4 id="验证minikube环境"><a href="#验证minikube环境" class="headerlink" title="验证minikube环境"></a>验证minikube环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">minikube start --kubernetes-version=v1.23.3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">minikube start会从Docker Hub上拉取镜像，以当前最新版本的Kubernetes启动集群。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--kubernetes-version，明确指定要使用的Kubernetes版本</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果以上命令执行后，镜像拉取失败，那么先执行minikube delete</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后执行minikube start --kubernetes-version=v1.23.3 --image-mirror-country=<span class="string">&#x27;cn&#x27;</span> --force</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不能用root账号，使用普通用户加上--force</span></span><br></pre></td></tr></table></figure><p>现在Kubernets集群就在本地运行了，可以使用以下命令查看集群的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">minikube status</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果</span></span><br><span class="line">minikube</span><br><span class="line">type: Control Plane</span><br><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line">apiserver: Running</span><br><span class="line">kubeconfig: Configured</span><br><span class="line"></span><br><span class="line">minikube node list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果</span></span><br><span class="line">minikube192.168.49.2</span><br></pre></td></tr></table></figure><p>可以看到，Kubernetes集群里现在只有一个节点，名字就叫：minikube，类型是Control Plane，里面有三个服务：host、kubelet、apiserver；IP地址是192.168.49.2。</p><p>可以使用命令minikube ssh登录到这个节点：</p><p><img src="/load_images/k8s/1/k8s_1_2.png" alt="image"></p><h4 id="kubectl命令"><a href="#kubectl命令" class="headerlink" title="kubectl命令"></a>kubectl命令</h4><p>使用minikube自带的kubectl有一点形式上的限制，要在前面加上minikube前缀，后面再有个–，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl version #这条命令还不能直接用，要用下面这种写法</span><br><span class="line">minikube kubectl -- version</span><br></pre></td></tr></table></figure><p>为了避免这个麻烦，使用alias别名功能，写到当前用户目录下的.bashrc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias kubectl=&quot;minikube kubectl --&quot;</span><br><span class="line">source &lt;(kubectl completion bash) #kubectl命令补全功能</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><p>现在就可以使用kubectl了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl version --short</span><br><span class="line"></span><br><span class="line">Client Version: v1.23.3</span><br><span class="line">Server Version: v1.23.3</span><br></pre></td></tr></table></figure><h4 id="运行一个Nginx应用"><a href="#运行一个Nginx应用" class="headerlink" title="运行一个Nginx应用"></a>运行一个Nginx应用</h4><p>命令与docker一样，也是run，不过形式有一点区别，需要用–image指定镜像，然后Kubernetes会自动拉取并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run ngx --image=nginx:alpine</span><br></pre></td></tr></table></figure><p>Kubernetes中的Pod概念，可以理解为”穿了马甲“的容器，查看Pod列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br><span class="line"></span><br><span class="line">NAME   READY   STATUS    RESTARTS   AGE</span><br><span class="line">ngx    1/1     Running   0          2d9h</span><br></pre></td></tr></table></figure><p>可以看到，在Kubernetes集群里有一个ngx的Pod在运行，到此我们这个单节点的minikube环境已经搭建成功了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://codeman.club/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://codeman.club/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Description</title>
    <link href="https://codeman.club/once/description/"/>
    <id>https://codeman.club/once/description/</id>
    <published>2022-09-22T07:07:31.000Z</published>
    <updated>2022-09-24T07:42:51.867Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog"><a href="#Welcome-to-my-blog" class="headerlink" title="Welcome to my blog!"></a>Welcome to my blog!</h3><p>此博客正在进行迁移工作，博客会持续更新。</p><p>Moving！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Welcome-to-my-blog&quot;&gt;&lt;a href=&quot;#Welcome-to-my-blog&quot; class=&quot;headerlink&quot; title=&quot;Welcome to my blog!&quot;&gt;&lt;/a&gt;Welcome to my blog!&lt;/h3&gt;&lt;p&gt;此博客正</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx-HTTPS</title>
    <link href="https://codeman.club/nginx/https/"/>
    <id>https://codeman.club/nginx/https/</id>
    <published>2022-03-25T07:01:59.000Z</published>
    <updated>2022-11-07T02:48:38.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx-HTTPS"><a href="#Nginx-HTTPS" class="headerlink" title="Nginx-HTTPS"></a>Nginx-HTTPS</h2><span id="more"></span><h3 id="HTTP协议存在的问题"><a href="#HTTP协议存在的问题" class="headerlink" title="HTTP协议存在的问题"></a>HTTP协议存在的问题</h3><ul><li>数据使用明文传输，可能被黑客窃取</li><li>报文的完整性无法验证，可能被黑客篡改</li><li>无法验证通信双方的身份，可能被黑客伪装</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li>所谓HTTPS，其实只是身披TLS&#x2F;SSL协议外壳的HTTP</li><li>HTTPS并非一个应用层协议</li></ul><img src="/load_images/nginx_https1.png" alt="image" style="zoom: 33%;" /><p>HTTPS &#x3D; HTTP + <strong><u>TLS&#x2F;SSL</u></strong> （解决了HTTP协议存在的问题）</p><ul><li>数据使用明文传输，可能被黑客窃取  → <strong>信息加密</strong></li><li>报文的完整性无法验证，可能被黑客篡改  → <strong>数字签名</strong></li><li>无法验证通信双方的身份，可能被黑客伪装 → <strong>数字证书</strong></li></ul><h4 id="HTTPS解决信息被窃取的问题——加密"><a href="#HTTPS解决信息被窃取的问题——加密" class="headerlink" title="HTTPS解决信息被窃取的问题——加密"></a>HTTPS解决信息被窃取的问题——加密</h4><h5 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h5><p>常见算法：DES、AES、3DES</p><img src="/load_images/nginx_https2.png" alt="image" style="zoom: 33%;" /><ul><li>优势<ul><li>解密效率高，客户端和服务器使用相同的密钥，密钥协商成本比较低</li></ul></li><li>劣势<ul><li>密钥无法实现安全传输，客户端和服务器使用相同的密钥进行加密解密，如果密钥被窃取，那么数据就相当于明文传输</li><li>密钥数目难于管理，多个客户端会协商生成多个密钥，高并发场景下开销会很大</li><li>无法提供信息完整性校验，可以窃取修改报文，导致报文不完整</li></ul></li></ul><h5 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h5><p>非对称加密算法：RSA、DSA、ECC</p><img src="/load_images/nginx_https3.png" alt="image" style="zoom: 33%;" /><ul><li>优势<ul><li>服务器仅维持一个私钥即可</li></ul></li><li>劣势<ul><li>公钥是公开的</li><li>非对称加密算法加密解密过程中会耗费一定时间</li><li>公钥并不包含服务器信息，存在中间人攻击的可能性</li></ul></li></ul><h5 id="HTTPS加密的原理"><a href="#HTTPS加密的原理" class="headerlink" title="HTTPS加密的原理"></a>HTTPS加密的原理</h5><p>混合使用对称加密和非对称加密</p><ul><li>连接建立阶段使用非对称加密算法</li><li>内容传输阶段使用对称加密算法</li></ul><h5 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h5><p><img src="/load_images/nginx_https4.png" alt="image"></p><h4 id="HTTPS解决报文被篡改的问题——数字签名"><a href="#HTTPS解决报文被篡改的问题——数字签名" class="headerlink" title="HTTPS解决报文被篡改的问题——数字签名"></a>HTTPS解决报文被篡改的问题——数字签名</h4><ul><li>确定消息是由发送方签名发送过来，因为别人假冒不了发送方的签名</li><li>能确定消息的完整性，证明数据从未被其他人篡改过</li></ul><h5 id="数字签名生成流程"><a href="#数字签名生成流程" class="headerlink" title="数字签名生成流程"></a>数字签名生成流程</h5><img src="/load_images/nginx_https5.png" alt="image" style="zoom:33%;" /><h5 id="数字签名校验流程"><a href="#数字签名校验流程" class="headerlink" title="数字签名校验流程"></a>数字签名校验流程</h5><img src="/load_images/nginx_cache5.png" alt="image" style="zoom: 33%;" />]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Nginx-HTTPS&quot;&gt;&lt;a href=&quot;#Nginx-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;Nginx-HTTPS&quot;&gt;&lt;/a&gt;Nginx-HTTPS&lt;/h2&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://codeman.club/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://codeman.club/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-缓存</title>
    <link href="https://codeman.club/nginx/cache/"/>
    <id>https://codeman.club/nginx/cache/</id>
    <published>2022-03-23T16:38:04.000Z</published>
    <updated>2022-11-07T02:48:49.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h2><span id="more"></span><h3 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h3><ul><li>客户端缓存（浏览器一般默认开启）<ul><li>优势：直接在本地获取内容，没有网络消耗，响应最快</li><li>缺点：仅对单一用户生效</li></ul></li></ul><img src="/load_images/nginx_cache2.png" alt="image" style="zoom:33%;" /><ul><li>服务端缓存<ul><li>优点：对所有用户生效；有效降低上游应用服务器的压力</li><li>缺点：用户仍然有网络消耗</li></ul></li></ul><img src="/load_images/nginx_cache1.png" alt="img" style="zoom:33%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次请求进来，会通过Nginx和应用服务器进行交互，Nginx拿到应用服务器的响应后，现根据自身的缓存策略进行缓存数据，然后数据和缓存标识一起返回给客户端；</span><br><span class="line"></span><br><span class="line">第二次请求进来（携带缓存标识），Nginx会根据缓存标识判断是直接从缓存中返回，还是和应用服务器交互之后返回</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache</span> zone | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_cache</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义用于缓存的共享内存空间；同一个zone可以在多个地方使用。</span><br><span class="line">off参数禁用从先前配置级别继承的缓存。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_path</span> path [levels=levels] [use_temp_path=<span class="literal">on</span>|<span class="literal">off</span>] keys_zone=name:size </span><br><span class="line">[inactive=time] [max_size=size] [min_free=size] [manager_files=number] </span><br><span class="line">[manager_sleep=time] [manager_threshold=time] [loader_files=number] </span><br><span class="line">[loader_sleep=time] [loader_threshold=time] [purger=<span class="literal">on</span>|<span class="literal">off</span>] </span><br><span class="line">[purger_files=number] [purger_sleep=time] [purger_threshold=time];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http</span></span><br><span class="line"></span><br><span class="line">设置缓存的路径和其他参数。缓存数据存储在文件中。</span><br><span class="line">缓存中的文件名是对<span class="attribute">cache</span> key（proxy_cache_key）应用MD5函数的结果</span><br><span class="line">levels参数定义缓存的层次结构级别：从<span class="number">1</span>到<span class="number">3</span>，每个级别接受值<span class="number">1</span>或<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当levels=1:2时，表示是两级目录，1和2表示用1位和2位16进制来命名目录名称。在此例中，第一级目录用1位16进制命名，如b；第二级目录用2位16进制命名，如2b。所以此例中一级目录有16个，二级目录有16*16=256个；</span></span><br><span class="line">/data/nginx/cache/b/2b/d7b6e5978e3f042f52e875005925e51b</span><br><span class="line">总目录数为<span class="number">16</span>*<span class="number">256</span>=<span class="number">4096</span>个。</span><br><span class="line"></span><br><span class="line"><span class="comment">#当levels=1:1:1时，表示是三级目录，且每级目录数均为16个：</span></span><br><span class="line">/data/nginx/cache/b/c/d/d7b6e5978e3f042f52e87500592</span><br><span class="line">总目录数为<span class="number">16</span>*<span class="number">16</span>*<span class="number">16</span>=<span class="number">4096</span>个。</span><br><span class="line"></span><br><span class="line"><span class="comment">#当levels=2:2:2时，表示是三级目录，且每级目录数均为16*16个：</span></span><br><span class="line">/data/nginx/cache/2b/3c/<span class="number">4d</span>/d7b6e5978e3f042f52e875005925e51b</span><br><span class="line">总目录数为<span class="number">256</span>*<span class="number">256</span>*<span class="number">256</span>个。</span><br><span class="line"></span><br><span class="line"><span class="comment">#被缓存的响应首先写入临时文件，然后文件被重命名</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>path 必选</td><td>缓存文件的存放路径</td></tr><tr><td>levels&#x3D;levels</td><td>定义缓存的层次结构级别：从1到3，每个级别接受值1或2</td></tr><tr><td>use_temp_path&#x3D;on|off</td><td>off直接使用path路径；on使用proxy_temp_path路径</td></tr><tr><td>keys_zone&#x3D;name:size 必选</td><td>所有活动的密钥和有关数据的信息都存储在共享内存区域中，其名称和大小由 keys_zone 参数配置<br />name是共享内存名称；size是共享内存大小；<br />1M的区域可以存储大约 8000 个密钥。</td></tr><tr><td>inactive&#x3D;time</td><td>在指定时间内没有被访问的缓存会被清理；默认10分钟</td></tr><tr><td>max_size&#x3D;size</td><td>设定最大缓存文件大小<br />当超过大小时，CM（Cache Manager）会删除最近最少使用的数据</td></tr><tr><td>min_free&#x3D;size</td><td>设定最小可用空间大小<br />当没有足够的可用空间时，CM（Cache Manager）会删除最近最少使用的数据</td></tr><tr><td>manager_files&#x3D;number</td><td>CM清理一次缓存文件，最大清理文件数；默认100</td></tr><tr><td>manager_sleep&#x3D;time</td><td>CM清理一次后进程的休眠时间；默认50ms</td></tr><tr><td>manager_threshold&#x3D;time</td><td>CM清理一次最长耗时；默认200ms</td></tr><tr><td>loader_files&#x3D;number</td><td>CL（Cache Loader）每次加载文件的最大数量；默认100</td></tr><tr><td>loader_sleep&#x3D;time</td><td>CL加载缓存文件到共享内存后，进程休眠时间；默认50ms</td></tr><tr><td>loader_threshold&#x3D;time</td><td>CL每次载入文件到共享内存的最大耗时，默认200ms</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_temp_path</span> path [level1 [level2 [level3]]];</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_temp_path</span> proxy_temp;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义一个目录，用于存储从代理服务器接收到的数据的临时文件；指定目录下最多可以使用三级子目录层次结构</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">在以下配置中：</span><br><span class="line"><span class="attribute">proxy_temp_path</span> /spool/nginx/proxy_temp <span class="number">1</span> <span class="number">2</span>; </span><br><span class="line">临时文件可能如下所示：</span><br><span class="line">/spool/nginx/proxy_temp/7/45/00000123457</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_key</span> string;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_cache_key</span> <span class="variable">$scheme</span><span class="variable">$proxy_host</span><span class="variable">$request_uri</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义缓存的key</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_valid</span> [code ...] time;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">为不同的响应代码设置缓存时间</span><br><span class="line"></span><br><span class="line"><span class="comment">#为200和302的响应设置10分钟的缓存，为404的响应设置1分钟</span></span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">404</span>      <span class="number">1m</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果只指定time，那么只有200、301和302响应被缓存。</span></span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#此外，可以指定 any 参数来缓存任何响应</span></span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">301</span> <span class="number">1h</span>;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#缓存的参数也可以直接在响应头中设置。这比使用指令设置缓存时间具有更高的优先级。</span></span><br><span class="line">header中的X-Accel-Expires字段设置响应的缓存时间（以秒为单位）；设置为0则禁止使用响应缓存。</span><br><span class="line">如果header中不包含“X-Accel-Expires”字段，可以在header中的“Expires”或“Cache-Control”字段设置缓存参数</span><br><span class="line">如果header中包含“Set-Cookie”字段，则不会缓存此类响应</span><br><span class="line">如果header中包含具有特殊值“*”的“Vary”字段，则不会缓存此类响应</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量</span></span><br><span class="line">$<span class="attribute">upstream_cache_status</span></span><br><span class="line"></span><br><span class="line">资源缓存的状态</span><br><span class="line"></span><br><span class="line">状态可以是以下值：</span><br><span class="line">MISS：未命中缓存，请求被发送到应用服务器，应用服务器响应后将响应内容缓存</span><br><span class="line">HIT：命中缓存，直接返回缓存内容</span><br><span class="line">EXPIRED：缓存过期，请求被发送到应用服务器，应用服务器响应后将响应内容缓存</span><br><span class="line">STALE：命中 proxy_cache_use_stale 指令设置的条件时，既服务器出现错误时，返回过期的缓存数据时，会返回这个状态码</span><br><span class="line">REVALIDDATED：Nginx验证陈旧缓存依然有效</span><br><span class="line">UPDATING：当缓存已经过期，正在被其他nginx worker进程更新时，返回该状态</span><br><span class="line">BYPASS：当命中 proxy_cache_bypass 中设置的条件时，直接从后端源站返回内容，该变量状态变为BYPASS</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_bypass</span> string ...;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义不从缓存中获取响应的条件</span><br><span class="line">如果string参数中至少有一个值不为空且不等于“0”，则不会从缓存中获取响应</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_cache_bypass</span> <span class="variable">$cookie_nocache</span> <span class="variable">$arg_nocache</span><span class="variable">$arg_comment</span>;</span><br><span class="line"><span class="attribute">proxy_cache_bypass</span> <span class="variable">$http_pragma</span>    <span class="variable">$http_authorization</span>;</span><br><span class="line"></span><br><span class="line">可以与 <span class="attribute">proxy_no_cache</span> 指令一起使用</span><br></pre></td></tr></table></figure><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8009</span>;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html/test1;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">add_header</span> X-Accel-Expires <span class="number">5</span>; <span class="comment">#通过响应头来设置缓存过期时间</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8010</span>;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html/test2;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">add_header</span> X-Accel-Expires <span class="number">5</span>; <span class="comment">#通过响应头来设置缓存过期时间</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置共享内存及缓存路径</span></span><br><span class="line"><span class="attribute">proxy_cache_path</span> cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_temp:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> cache_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8009</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8010</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">95</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_cache</span> cache_temp; <span class="comment">#开启缓存并指定共享内存空间</span></span><br><span class="line">                <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">5m</span>; <span class="comment">#针对200响应设置5分钟缓存时间</span></span><br><span class="line">                <span class="attribute">proxy_cache_key</span> <span class="variable">$host</span><span class="variable">$request_uri</span>; <span class="comment">#设置cache key</span></span><br><span class="line">                <span class="attribute">add_header</span> Nginx-cache-status <span class="variable">$upstream_cache_status</span>; <span class="comment">#添加响应头字段，用来展示缓存状态</span></span><br><span class="line">                <span class="attribute">proxy_pass</span> http://cache_server;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：X-Accel-Expires优先级比proxy_cache_valid高，所以X-Accel-Expires会导致proxy_cache_valid设置无效，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以可以注释掉其中一个来模拟缓存情况，当然两个都存在也不影响正常运行</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本次示例上游服务器设置X-Accel-Expires为5秒，代理服务器proxy_cache_valid设置为5分钟</span></span><br></pre></td></tr></table></figure><img src="/load_images/nginx_cache3.png" alt="image-20221025002427581"  /><h3 id="配置Nginx不缓存特定内容"><a href="#配置Nginx不缓存特定内容" class="headerlink" title="配置Nginx不缓存特定内容"></a>配置Nginx不缓存特定内容</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_no_cache</span> string ...;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义不将响应保存到缓存的条件</span><br><span class="line">如果string参数中至少有一个值不为空且不等于“0”，则不会保存响应</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_no_cache</span> <span class="variable">$cookie_nocache</span> <span class="variable">$arg_nocache</span><span class="variable">$arg_comment</span>;</span><br><span class="line"><span class="attribute">proxy_no_cache</span> <span class="variable">$http_pragma</span>    <span class="variable">$http_authorization</span>;</span><br><span class="line"></span><br><span class="line">可以与 <span class="attribute">proxy_cache_bypass</span> 指令一起使用</span><br></pre></td></tr></table></figure><h4 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8011</span>;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html/test1; <span class="comment">#目录下有123.txt，abc.text，index.html</span></span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8012</span>;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html/test2; <span class="comment">#目录下有123.txt，abc.text，index.html</span></span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_temp:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> cache_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domian:<span class="number">8009</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8010</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">96</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果uri以.txt或.text结尾，则设置自定义变量$no_cache</span></span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$request_uri</span> <span class="regexp">~ \.(txt|text)$</span> ) &#123;</span><br><span class="line">                <span class="attribute">set</span> <span class="variable">$no_cache</span> <span class="string">&quot;no cache&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_cache</span> cache_temp;</span><br><span class="line">                <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">5m</span>;</span><br><span class="line">                <span class="attribute">proxy_cache_key</span> <span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">                <span class="attribute">proxy_no_cache</span> <span class="variable">$no_cache</span>; <span class="comment">#如果$no_cache不为空或0，则不进行缓存</span></span><br><span class="line">                <span class="attribute">add_header</span> Nginx-cache-status <span class="variable">$upstream_cache_status</span>;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://cache_server;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:96/index.html -I</span><br><span class="line">curl 127.0.0.1:96/index.html -I</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问index.html可以看到会命中缓存(或去proxy_cache_path目录查看缓存文件)</span></span><br><span class="line"></span><br><span class="line">curl 127.0.0.1:96/123.txt -I 或者 curl 127.0.0.1:96/abc.text -I</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行多次此命令，也不会进行缓存，Nginx-cache-status标识为MISS(或去proxy_cache_path目录查看是否有新缓存文件)</span></span><br></pre></td></tr></table></figure><h3 id="缓存失效降低上游压力机制"><a href="#缓存失效降低上游压力机制" class="headerlink" title="缓存失效降低上游压力机制"></a>缓存失效降低上游压力机制</h3><h4 id="合并源请求"><a href="#合并源请求" class="headerlink" title="合并源请求"></a>合并源请求</h4><img src="/load_images/nginx_cache4.png" alt="image" style="zoom: 33%;" /><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_lock</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_cache_lock</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">1</span>.<span class="number">12</span>.</span><br><span class="line"></span><br><span class="line">当参数为<span class="literal">on</span>时，一次只允许一个请求（cache key相同的请求）通过，将请求传递给代理服务器，并缓存返回的响应。</span><br><span class="line">其他请求要么等待响应出现在缓存中，要么等待缓存锁被释放，直到proxy_cache_lock_timeout指令设置的时间。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_lock_timeout</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_cache_lock_timeout</span> <span class="number">5s</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">1</span>.<span class="number">12</span>.</span><br><span class="line"></span><br><span class="line">为 proxy_cache_lock 设置超时时间；当时间到期时，其他请求将被传递到代理服务器，但是响应不会被缓存。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_lock_age</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_cache_lock_age</span> <span class="number">5s</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">7</span>.<span class="number">8</span>.</span><br><span class="line"></span><br><span class="line">如果在指定时间内，传递给代理服务器以填充新缓存的最后一个请求未完成，则可能会再向代理服务器传递一个请求</span><br></pre></td></tr></table></figure><h5 id="简单示例-2"><a href="#简单示例-2" class="headerlink" title="简单示例"></a>简单示例</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_temp:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> cache_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domian:<span class="number">8009</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8010</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">96</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果uri以.txt或.text结尾，则设置自定义变量$no_cache</span></span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$request_uri</span> <span class="regexp">~ \.(txt|text)$</span> ) &#123;</span><br><span class="line">                <span class="attribute">set</span> <span class="variable">$no_cache</span> <span class="string">&quot;no cache&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_cache</span> cache_temp;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">5m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_key</span> <span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line"><span class="attribute">proxy_no_cache</span> <span class="variable">$no_cache</span>; <span class="comment">#如果$no_cache不为空或0，则不进行缓存</span></span><br><span class="line"><span class="attribute">add_header</span> Nginx-cache-status <span class="variable">$upstream_cache_status</span>;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://cache_server;</span><br><span class="line">        </span><br><span class="line"><span class="attribute">proxy_cache_lock</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_cache_lock_timeout</span> <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">proxy_cache_lock_age</span> <span class="number">5s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启用陈旧缓存"><a href="#启用陈旧缓存" class="headerlink" title="启用陈旧缓存"></a>启用陈旧缓存</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_use_stale</span> <span class="literal">error</span> | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | <span class="literal">off</span> ...;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_cache_use_stale</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">确定在哪些情况下可以在与代理服务器通信期间使用过时的缓存响应。该指令的参数与 <span class="attribute">proxy_next_upstream</span> 指令的参数相似。</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>error</td><td>与上游服务器建立连接、发送请求、读取响应头出错时，则允许使用过期的缓存响应。</td></tr><tr><td>timeout</td><td>与上游服务器建立连接、发送请求、读取响应头超时时，则允许使用过期的缓存响应。</td></tr><tr><td>invalid_header</td><td></td></tr><tr><td>updating</td><td>缓存过期，正在更新，则允许使用过期的缓存响应</td></tr><tr><td>http_500</td><td>返回状态码为500时</td></tr><tr><td>http_502</td><td>返回状态码为502时</td></tr><tr><td>http_503</td><td>返回状态码为503时</td></tr><tr><td>http_504</td><td>返回状态码为504时</td></tr><tr><td>http_403</td><td>返回状态码为403时</td></tr><tr><td>http_404</td><td>返回状态码为404时</td></tr><tr><td>http_429</td><td>返回状态码为429时</td></tr><tr><td>off</td><td>不允许使用过期缓存</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_background_update</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_cache_background_update</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">11</span>.<span class="number">10</span>.</span><br><span class="line"></span><br><span class="line">允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。（后台更新缓存，先把过期缓存返回给客户端）</span><br><span class="line">如果参数为<span class="literal">on</span>，请注意，有必要在更新时允许使用过期的缓存响应（ proxy_cache_use_stale updating ）</span><br></pre></td></tr></table></figure><h5 id="简单示例-3"><a href="#简单示例-3" class="headerlink" title="简单示例"></a>简单示例</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_temp:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> cache_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domian:<span class="number">8009</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8010</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">96</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果uri以.txt或.text结尾，则设置自定义变量$no_cache</span></span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$request_uri</span> <span class="regexp">~ \.(txt|text)$</span> ) &#123;</span><br><span class="line">                <span class="attribute">set</span> <span class="variable">$no_cache</span> <span class="string">&quot;no cache&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_cache</span> cache_temp;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">5m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_key</span> <span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line"><span class="attribute">proxy_no_cache</span> <span class="variable">$no_cache</span>; <span class="comment">#如果$no_cache不为空或0，则不进行缓存</span></span><br><span class="line"><span class="attribute">add_header</span> Nginx-cache-status <span class="variable">$upstream_cache_status</span>;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://cache_server;</span><br><span class="line">        </span><br><span class="line"><span class="attribute">proxy_cache_lock</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_cache_lock_timeout</span> <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">proxy_cache_lock_age</span> <span class="number">5s</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">proxy_cache_use_stale</span> <span class="literal">error</span> timeout updating;</span><br><span class="line">        <span class="attribute">proxy_cache_background_update</span> <span class="literal">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ngx-cache-purge第三方缓存清除模块"><a href="#ngx-cache-purge第三方缓存清除模块" class="headerlink" title="ngx_cache_purge第三方缓存清除模块"></a>ngx_cache_purge第三方缓存清除模块</h3><ul><li>功能：根据接收的HTTP请求立即清除缓存</li><li>使用–add-module指令添加到Nginx中</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_cache_purge</span> zone key;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http、server、location</span></span><br><span class="line"></span><br><span class="line">zone：共享内存的名称</span><br><span class="line">key：proxy_cache_key定义的缓存</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8011</span>;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html/test1; <span class="comment">#目录下有123.txt，abc.text，index.html</span></span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8012</span>;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html/test2; <span class="comment">#目录下有123.txt，abc.text，index.html</span></span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#代理服务器</span></span><br><span class="line"><span class="attribute">proxy_cache_path</span> cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_temp:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> cache_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domian:<span class="number">8011</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8012</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">96</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果uri以.txt或.text结尾，则设置自定义变量$no_cache</span></span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$request_uri</span> <span class="regexp">~ \.(txt|text)$</span> ) &#123;</span><br><span class="line">                <span class="attribute">set</span> <span class="variable">$no_cache</span> <span class="string">&quot;no cache&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_cache</span> cache_temp;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">5m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_key</span> <span class="variable">$host</span><span class="variable">$uri</span>;</span><br><span class="line"><span class="attribute">proxy_no_cache</span> <span class="variable">$no_cache</span>; <span class="comment">#如果$no_cache不为空或0，则不进行缓存</span></span><br><span class="line"><span class="attribute">add_header</span> Nginx-cache-status <span class="variable">$upstream_cache_status</span>;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://cache_server;</span><br><span class="line">        </span><br><span class="line"><span class="attribute">proxy_cache_lock</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_cache_lock_timeout</span> <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">proxy_cache_lock_age</span> <span class="number">5s</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">proxy_cache_use_stale</span> <span class="literal">error</span> timeout updating;</span><br><span class="line">        <span class="attribute">proxy_cache_background_update</span> <span class="literal">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ /cache_purge(/.*)</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_cache_purge</span> cache_temp <span class="variable">$host</span><span class="variable">$1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1/123.txt -I</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">缓存未命中</span></span><br><span class="line">curl 127.0.0.1/123.txt -I</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">缓存命中</span></span><br><span class="line"></span><br><span class="line">curl 127.0.0.1/cache_purge/123.txt -I</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清除缓存</span></span><br><span class="line"></span><br><span class="line">curl 127.0.0.1/123.txt -I</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">缓存未命中</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Nginx缓存&quot;&gt;&lt;a href=&quot;#Nginx缓存&quot; class=&quot;headerlink&quot; title=&quot;Nginx缓存&quot;&gt;&lt;/a&gt;Nginx缓存&lt;/h2&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://codeman.club/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://codeman.club/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx中的http_proxy_module</title>
    <link href="https://codeman.club/nginx/http_proxy_modyle/"/>
    <id>https://codeman.club/nginx/http_proxy_modyle/</id>
    <published>2022-03-20T10:52:34.000Z</published>
    <updated>2022-11-07T02:48:32.326Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7f0db84661f840ccba1562f3329a2f3ab4e8024a05b7b42edf3f426759d9931e">cc4eaccd88a7cf11990f2cd15dba71878958af4fad6254f56ab6d6066d662dbb5a69a5e4654f019acb68ccef866b77da74a3e1b09e1e99aa50a6eb99d588618ba5328c0628290beb973610c4bb16200d10726c86566942e3cf7541efc65e3b3373729c243de09864138b94b29efdd69e74c23cb5d3cd3b8e34b7befd7bf110050baaf38ca3198d1d3d84446199163ac88cf27a2090c05605ece53fdcbd4a686b00dc59f1a45590b4f507b339cfab3407c7633c3d2abcfdd14fc8bef78b380bb9e222c577281ed983be88d5ea6b02401a0fb21cf300d38be7d450f5066f37243b9b2bc2a855f6e269dcbf20d66728d527f054d965353db51fb7fc63eb0eda25aa05fe9ccdbc444ec7f2dc6202417ede5935f506be7ac1e9963bc9746e8bc3f7b5d0aa0b5798f812610bef2d41cf99a3edc4685173c00bc736557c3fffcdbbc01ea8fd1ce08e9e915f8a2a27661114fe3664018dbc1ce3e27e193c573ce075b9c5f4a769c78b5e188bb87ca0eac31735b0b7b5c629e29a04ce147d0a74a5bb088b9e0c1b521c7f9a29a98dbb707dc0ece456e8451857634d00fc93e2754ee8cb1c6799267178c81482afa559c11d99dab53cb6be817fcfb59681ca72ea76175051d92119ebb6468f8486d636a50830a73d11c28d9296bc05c96ab344a342e5ee1025e3e950cc9751abbaf2af6fb20f3c53d06cc704053da6ff83e827160f3f241e2914cc535b6ce673884cbbe19d0b00518f119f4c748878f10707553ff9e59feb718827881cfd30832e86db82a8e3d509a1736de79e33b67e21f3a24ddb87e02a698fbe861748aed1df252ddcd0cdf3ff62cdabfa73009ff144e91040de0c6f105a90ee5f02c65e5528909b98aba560d07735a608d8c6d668e745c82a37ac31cda91dd5320d1fd512d6671c8f1e0c6b76e07cd7201786cac3c79f87b50cd9b4cb0d583704a6e173f08719b7f70ffce2185be3966b95efb46bccc8b6af51b9bbf148384ac3b572e60ce4ead89463af610565bde3b710282a13b8551abe358a667162cb93b780624ddae2810a923e04c2dde3f59faf13530686a4dc0a2e07db5f6773b552c1d0282b1af0f9e987999d212d579432787d64db6db5aae16e17f5af0cb518f86b776bbfe39bed0111d21ed869cbf70903d92ea59eae11a0455ee91f15bcf2922d553d751fb74be7d9685d22b21cf0872c64ac18747e1b584c5f61cbe58fd7c82cb51373d8ff047d14631c3fb447c8481a0d64e73d85cfcf0e914802c36c87a2eb844c29e4f8cccb636d1901206fdeb9d228b96c146dd2fbe768aa166f04ca0af31414b2db68e23961e6c505c4f8679fc734c8c160fdedfb60b32e3239c53b934334c2e1059de2e81d396b5299aa08abb944aa6b7f92cd95426d3f4102decd9533bc508afc1c7775dbd1bf0b5f613d790b12b3a578ab112ab135686f05c486505bcaf7bfd450b7ac5d9bc2806c09c26d7cc13e30b4c932868cecc78040a2265c846b8ff16fa95a1e3f50d120ed246e85ba4a22f077ae8b133a58ba6add37e366c8f8c98700b99ef0517d3347125865820fb8216938c5d0ce4187cd26f8c2284f8f0d794abe466cbcec70816eeef704bce958293ec2ccc69617ea4ef535f3ad9c6af564dfac6c76c4c06a452d441cc2b9c22772e3b5058a7e5c08a9323fbf5c39ee4d1699bd50c617bb29d45ed4004e19a39874ba2abc447a7147745ac6bff828c7a784077a22e68ff8ad81a931186dbb0f5bab04f2628d92e8267df7fa8a8242ccc8c6e473eea48466a8d2ee568e850028521e6952d89cebee97233609c08abb4cc0b70cedd5892e9dc674434a5475733109e1c3a510784ba60c0ea2c33ca9cb91db78276cb9dc68c519fad927acd2af6bc7dafaed992d60a1585265ee0654bb669178d8292b43cf40a3603a2c99e9291914b51895492b72bd22f3f525caef2363012db61037618e230c234a09da042e03ae2d0965f8c578c07c170f72533feea4676c063129b9b267d1cfca816b31848ca9866905f2f3c20a6a9e9889d5d6ddba2c9a1ece39748afb7792a7457b4fc9aabcc60ed580e32adcb229357ac804bf13a385eff6bb8f4fd6880e46fb4ccbc4a66fdb6a5d0aa25cf010e477c6d23eda4062b9640629e1ecc5f966245ca5a4ad9428f791478a6a6622c8e766620582981e43cfc7df6816f68298ac17dacea34c0ab3f826ce3dd0210ae3539e0605099dca5a68eb2bd8009ffb225ad41eaddb6b9aef19bce3fb0f32f3e9daf203aa872cd29483d2f1b3d15ecf01424107f2e6e132caf122812da30c5cfac762af0390dbffe9daecf3d410b45a03d1cebc30920911a8b5f8958509b054dfd33b8a05c0c14e4829ccb968fe71b29de8fcc2a635ea4609bea4af66d856f7ace6d8e8a4372b370cbba8e813c992fffa4656c0002e23e05596b27bdcbc61163313f6173d7111a6e4fef22f8a0b2f8c8f7d3187d66add561bab497222da7173069f1e8a5bd084467b7e36e274e87ab7ded8e8c1268d8e3926e09438227eeff645c77cb1beafe811dc6f0625def6e7050d7f121aa7a7b7735c44c307131ac23750edb84a565f9a49643120147dd8a340a7cd9073146a413f3c3a3a733a200d5ded95d2bd89da101c48c98bbcf38f47f8f00f3fb19b24857f12ee9519daffd3126e2f862c788604eff14580afa32895a7366339b00916010ed1eac8c914dbe84d56598bda2d2a05d0ab4505abde5d0c4f61cd40fa7851e89a8ca2236b62bbe79f87c24c8ab1ddf6bd667cb14f4fe8e43e3feac87a1a76600563ada82f67b893a241332b9fa16ee7920eaf3d6f84384bf0e40b8c0c71a2e0fe203da3a22d82501d95dfee402a5e44e24267d7e776b3671251e8b5561d328fc1d34e9974aaa0749b25e0e3cb40f6c601fa344715d98012d51e1535f6f74aefac4463152398b09a50c765c4b45f26caf1da9fcc88721aa17e61a4a71a7190ce7bd92174adaae244f3acd556d41ea5671342ec336b27bb233acc763ce6cb1a40de564acbe481e896ea1319a2e7e51180ad12d5d6b609aeabd8efe39a9982ecaf8a699865cc85326d68f3a621d92a4d46cedf382912fb26320149ed12179e51794e384efffb2ed7549fa420eff7dcaa3708cb230ce9ec98d90488ce6de4bf6e7c764d3cc1bedccc7c136e82b40fb9332074e130f99caf947907759f2a42d37eb8aba845b2b97c565ff0de500e0e83fa5c5d2c39f275009275da273d06973490394637c065b302472ed81446400cde628eeaed92cbf1d758c5b341497fa10278ea69bde98ce6366ae3c9904ae2058d16d3804d7eef7cb6fe9d48700c248fc3aa1b38396c3d4738182c995c510328837620a369c3f518e3c04e5209bf498d78b63440b1ccc094aad215992987051f2f53b2e179a395109405a079c18addef0bd4d6563134d2fe1fbdd90f84f90c22b0cf08e104dda5b81a14df2ca972000ea10f39c9577695d463d1c2e2690792b515a2e740199160bdf071d75595b61461e587fa2f912178f0825d4039258cde16aa208da3577fb9cff86440fc102e9378687c26fcbc84734e3777c311e29772cd0663891c1f5452dc2e09902c4ddec3007c8d23be654ab154b42c305fce04e9dcde946019be544c18a7c3ff94001cd6b07f6196ebbcc4ac94ba4410f125cbfc1b9dee13ecbc5d822ffb629823593253d4bbd89acbc5c48096d364c285eb2a6d24378bd7773dff70fb616ac545009c9d238f8297eef7ef376f1a14525659efd2f99fbf8859f51b4337026e8e6dbd13af77b7660403e7451745b3abbbbe57dd3ba6bb2e5411cfcfb4e7cbd1826ed1248e4643cbb71b90019c769a6855fa9a2021b6098f6ae4bee6d57ce1c201f4a3323b8d5859dc95f57d4c755f6e38f1c3fba22f6822a0733c2460f742f647ccd7298f7bd22e98e4c4e9db56c05a5f609e5e341db885cc5f77dd3d5919b67ea6e7fd4af73c917b6a1d4ee6182f2f4f94610ef2aef1d429da981ee0f921300b750a1b66a1224de2620e979fa47da2b044e08c3a53deace8786cf58157780ea245106fe614b9db154738ee1ee4b188714bfe828994a5ae8ee5e40e0c06bfe1c144b945b48ead78439139ec1de3be187b75380cb27294ffd7e449f77e6c674dc6542c1a1bc15791f7a986157b4266687b166bbe1506756117c0cd232a0871268c214da33764ed64d7b2b2d84b66c75c0c874346401c491801a50adf018307e717d9327448507dc6f1cc790e25b1aa558c08df67f61f50ef9b472e22ae3964a4a63693c7e7e7a0e3a1e1092033168142ec5647d5a4d6fe4f74a6b0e2167a3d2f51b6a7c8557bc2d399787c75d5edeee366a153902ccf170634fc781b66d9c3d317a87269230918d461e6d7921539bec17d39177a05aa3cf9c25a7aac81cfc1c1f20d98ae9b5a5247aef50a4adfec47aabf5bddd39bd71038782247d98223f6cfa807590b706df6242c8771c067c7e26c1739604d934b90d93b7010b360bddaae71e43d9207c0ed9993e726d3f9296933038880b8d861fd125a947c8e4d45d7c904b37e2b4c174df483ed1f1f3ad2e900afbe603b210a31dde2bed0ea4ce0e8cba0057446a317383157a6f5e337c948d3280602cd1b2a2b4d0a9453127a9cffb84c0bbdeaab33ab0b004db37f6b4a47ae1ab77f2b3d550f80c4b23ba6afbcc8f7e7c3e5524f69544dd2bf004000cfc34566e57993b9452003746a229651f70fcedb420f67d90dd6ff117e95e5020a1ad6e6eeac413b1ba92aa109fa4356babcb962cc8b68056ba63d5005c68cda7451c3d660882a2c4852dacc49118b05fb3dadddb68831480b3139966caccdf9e17de198a3884f66ec1dad695dcceb607b42d038f0fb0a120565bd4e0ba3c84f6f471d1bab1169cc3f705a951dbe38d1d6dde7dfd51eb6e898716bc2d7f6021c5252107e63f13784c5f60c55992f4f1bdb67b8779f1cbd91dcc62d8e6121500e87fabaa09ddd5a7758204a5df0ea315c3af090c9693392b11853f86c6e99db66d99131d64cd4f924e71763aa654eb957876b741eb17afa0bdda90b0dc23c393b1df7617b065006c95dc473038a294b2ba8a4c7147039e1758667a919e4b4d8b062342c077103c8fb5008b270dd4e429e77ae3abe6cd8a4adf60aacd02058615991b53a058fc41cd0ec827535d738aeadd532e74d3197b4d364e56c1f2aa5c50e82d3624748549df16fce7630bc3d6b4b6d717bfcf6f746f409fda0727237826318235d7872edb85333c87ca61ea7fba288c6f51f11afda62f63e820e1781195aeffc1c4d95648e6c795a1dc7dd50f35dc2e4b6bc4a21c8f86bded7855a7b83751f1805d92f14f26ecac9260b40dd8f81679a3dee124d85ab2e7152b98f36f8d18cc4247a85312f5d4aef024bb71b2bc8b43ad4a42da9aa0f00292b1157777d01e02dad39aab6b4234a7fa4a2aa59fcbdea27d79f9f222ee359357d8a040586e700e7311721df464d42c0f3a24398ebec2b0b661d97ab3222c28327fb0dde989769ad9a2c527fc78e6a232624aaa4179139ba708fb07265a7ba28cc78b087f867cf5914e270389cd27b0c04bfe261931824f9b5797ae6f708d9dc249c9153ae7ce67872c32e27e6c17a508d3588253d6f70e8fce806756483b1c051e2bd23e3196d69dd88ce1a4aa5b791ef86acdac4bc90edcd26ff3986a8cd05c69041c64888839a0506a7d4012415fb1bb65aa250db87d3c14b3493fcc23d6e3770ff3cecafa773ab9434b40d1543e0a1fb8d09d2b7d77761b2171444bb37aae941c2cbda67f696c557a9bbc177c1e29e1a42659a2f9c1f19de94cef5b6f106f162a8cfcf1ccc9bd1bdc8fcc7beae88871b7581b53dd07af6877f01985f9b7e1d23b154859c552bed01496ccdaca2d6ffef457512832c19c07e0c641c51c1750c2de79dc0b9b596251013155d15735ec230cb3f1d5a79e14113d143480314ede75bc9721693fea4f5691bdf56855825cb6978889720aa2df50f9f092efe915c4cef5cb3e29664715263e5337b0850543f1756c640420fc63e0d887411cc7a8251de7fe0611fbea150764c9f151a05b5b2b18f5a77fa888c5b9829800ef6bd191a8de4f06fa343e9c5053d42f8de4b24236fdf94c6dc2910ae4a41048799841ee418bbe334b4ca8f92b9eee6cf5e2d24a244f1ca03a7756a09d72dadd78df87a6a1c29df2fcac8c7676e47b919707aac4e35e17b08814da0c816c8eff04ea875bccd1875bf17edd37538fec27e0597abdbc7b2da270a573091cc09d4ac9059e4944880247719425b815ad3b2912c46716e09e968a7e63f6b00c00b11b569530ce64b28a69359466f2307e93e9dd7d4c251a2e2ba9296ac030aaa98493c45eef2a72bec16e0b3107d19257cadc6a5b5234c2f9637ab27fdf77546bf272d5dc9c559dd37a440158c813838a8c857c8a492fe0efa78b19cf4a0fc1a79ee3537decb8e9d9a09ac7d9ddd96bda409bcd4d21a13ec59ee875ce9410348f531e2253e1656eba5d3a34140c9de6cf929ddb2a958e82a1d4d7c52ab300afa9cbd481248db088e2c36e0347dd63d0bfdf62e361d6a77803cc3ce730960c7260dd1cf4adb38e71a2b704b8d82cce1b8b1691cec9ed5de4aa88a74ea1316307f5edb333c80b059adcdf01b404aff12bf67d7caa7c411bb01544f83167e7841ae30fe3d8b2167d6a4270379d51343d0f2575d8e7020041a385fefc049d04dc4c77689c00d04f327302db5ff34f10c1f2d2879f4d1dac90ddbd95ad75f1d7b176269a6ff92e8f8f54419b6c0076161397bfb8c28c41ddd5260786101429384265766ef4608c33c3e34013ed9a7e8200d5d61eaf6cf2b3e779c0fc52a3466107699ac41315dab5f35b47402b57df65cd5d3b9464479f174c00525a230b6bb858ab257f70f19332b93692139dcc9a773d1542f9d15afba386df238b6801bed71226b38ffd64de14880dc9d8fe2facbe462d6b55024b75fffe5da779913a36d84a0a27039bc9f3da5e66e78502f07570e40a6c844cf298a51617168a3db2639bcec3b7ce656fd8b92295c4d7bd412104637c508bca99cbc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="Nginx" scheme="https://codeman.club/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://codeman.club/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-反向代理</title>
    <link href="https://codeman.club/nginx/reverse_proxy/"/>
    <id>https://codeman.club/nginx/reverse_proxy/</id>
    <published>2022-03-20T01:18:08.000Z</published>
    <updated>2022-11-07T02:49:06.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><span id="more"></span><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>反向代理介于用户和真实服务器之间，提供请求和响应的中转服务</li><li>对于用户而言，反向代理服务器就是访问的真实服务器</li><li>反向代理可以有效降低服务器的负载消耗，提升效率</li></ul><img src="/load_images/nginx_reverse_proxy1.png" alt="img" style="zoom: 33%;" /><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>隐藏真实服务器</li><li>便于横向扩充后端动态服务</li><li>动静分离，提升系统健壮性</li></ul><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动静分离是指在web服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提升整个服务访问性能和可维护性</span><br></pre></td></tr></table></figure><h4 id="Web资源分类"><a href="#Web资源分类" class="headerlink" title="Web资源分类"></a>Web资源分类</h4><img src="/load_images/nginx_reverse_proxy2.png" alt="img" style="zoom: 33%;" /><h4 id="Web请求图解"><a href="#Web请求图解" class="headerlink" title="Web请求图解"></a>Web请求图解</h4><p>静态请求Nginx本身可以处理（也可以单独做一个静态资源服务器专门处理静态请求），直接返回文件内容即可。动态请求可以打到动态资源服务器（也叫应用程序服务器）去处理，然后结果返回给Nginx，再返回给用户。</p><img src="/load_images/nginx_reverse_proxy3.png" alt="img" style="zoom: 33%;" /><img src="/load_images/nginx_reverse_proxy4.png" alt="img" style="zoom:33%;" /><h3 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h3><p>使用Nginx作为反向代理时支持的协议</p><img src="/load_images/nginx_reverse_proxy5.png" alt="img" style="zoom:33%;" /><h3 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h3><h4 id="用来定义上游服务的相关信息"><a href="#用来定义上游服务的相关信息" class="headerlink" title="用来定义上游服务的相关信息"></a>用来定义上游服务的相关信息</h4><img src="/load_images/nginx_reverse_proxy6.png" alt="img" style="zoom:33%;" /><ul><li>默认被编译进Nginx，禁用须通过–without-http_upstream_module</li></ul><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>upstream</td><td>段名，以{}括起来，中间定义上游服务URL</td></tr><tr><td>server</td><td>定义上游服务地址</td></tr><tr><td>zone</td><td>定义共享内存，用于跨worker子进程</td></tr><tr><td>keeplive</td><td>对上游服务器启用长连接</td></tr><tr><td>keeplive_requests</td><td>一个长连接最多请求个数</td></tr><tr><td>keepalive_time</td><td>限制通过一个长连接处理请求的最长时间。到了这个时间后，在后续的请求处理之后关闭连接</td></tr><tr><td>keeplive_timeout</td><td>空闲情形下，一个长连接的超时时长</td></tr><tr><td>hash</td><td>哈希负载均衡算法</td></tr><tr><td>ip_hash</td><td>依据IP进行哈希计算的负载均衡算法</td></tr><tr><td>least_conn</td><td>最少连接数负载均衡算法</td></tr><tr><td>least_time</td><td>最短响应时间负载均衡算法</td></tr><tr><td>random</td><td>随机负载均衡算法</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span>定义一组服务器</span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="section">upstream</span> name &#123; ... &#125;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http</span></span><br><span class="line"></span><br><span class="line">server可以监听不同的端口</span><br><span class="line">监听TCP和UNIX域套接字的服务器可以混合使用</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>       max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="attribute">server</span> unix:/tmp/backend3;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> backup1.example.com  backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">默认情况下，请求使用加权循环平衡方法在服务器之间分配</span><br><span class="line">上述示例，每7个请求将按以下方式分发：第一个server分配5个，第二、第三个server各一个；</span><br><span class="line">如果在与服务器通信时发生错误，请求被传递到下一个服务器，依次类推，直到尝试所有正常运行的服务器</span><br><span class="line">如果无法从任何服务器获得成功响应，那么客户端将收到与最后一个backup服务器通信的结果</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server语法</span></span><br><span class="line"><span class="attribute">server</span> address [parameters];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"></span><br><span class="line">address可以是IP、域名，也可以带上端口(默认80端口)，也可以是一个UNIX套接字路径</span><br><span class="line">解析为多个IP地址的域名一次定义多个服务器</span><br></pre></td></tr></table></figure><table><thead><tr><th>parameters可选值</th><th>含义</th></tr></thead><tbody><tr><td>weight&#x3D;number</td><td>权重值，默认为1</td></tr><tr><td>max_conns&#x3D;number</td><td>上游服务器的最大并发连接数</td></tr><tr><td>fail_timeout&#x3D;time</td><td>服务器不可用的判定时间</td></tr><tr><td>max_fails&#x3D;number</td><td>服务器不可用的检查次数</td></tr><tr><td>backup</td><td>备份服务器，仅当其他主服务器都不可用时，将被传递请求</td></tr><tr><td>down</td><td>标记服务器长期不可用，离线维护</td></tr><tr><td>resolve</td><td>监控服务器域名对应的IP地址变化，自动修改upstream配置，无需重启nginx；服务器组必须驻留在共享内存中</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">keepalive：限制每个worker子进程与上游服务器空闲长连接的最大数量</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">keepalive</span> connections;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#简单示例</span></span><br><span class="line"><span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#For HTTP</span></span><br><span class="line"><span class="section">upstream</span> http_backend &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /http/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://http_backend;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>; <span class="comment">#proxy_http_version需要设置为1.1</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>; <span class="comment">#proxy_set_header设置Connection为空</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#说明，如果不设置proxy_http_version为1.1，那么proxy_set_header需要设置Connection为Keep-Alive；不建议这么做</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#For FastCGI</span></span><br><span class="line"><span class="section">upstream</span> fastcgi_backend &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive</span> <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /fastcgi/ &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span> fastcgi_backend;</span><br><span class="line">        <span class="attribute">fastcgi_keep_conn</span> <span class="literal">on</span>; <span class="comment">#需要设置fastcgi_keep_conn为on</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#关于负载均衡注意点</span></span><br><span class="line">当使用默认循环方法以外的负载均衡方法时，需要在keepalive指令之前启用它们。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">keepalive_requests：设置一个keepalive连接可以处理的最大请求数。在发出最大请求数后，连接将关闭。</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">keepalive_requests</span> number;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">keepalive_requests</span> <span class="number">1000</span>; <span class="comment">#在1.19.10版本之前，默认值为 100</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">15</span>.<span class="number">3</span>.</span><br><span class="line"></span><br><span class="line">Closing connections periodically is necessary to free per-connection memory allocations. </span><br><span class="line">Therefore, using too high maximum number of requests could result in excessive memory usage and not recommended.</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keepalive_time：限制通过一个保活连接处理请求的最长时间。到了这个时间后，在后续的请求处理之后关闭连接</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">keepalive_time</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">keepalive_time</span> <span class="number">1h</span>;</span><br><span class="line"><span class="comment">#上下文upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">19</span>.<span class="number">10</span>.</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout：空闲连接的最长保持时间</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">keepalive_timeout</span> timeout;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">60s</span>;</span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">15</span>.<span class="number">3</span>.</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue：如果在处理请求时无法立即选择上游服务器，则该请求将被放入队列中</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">queue</span> number [timeout=time];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">5</span>.<span class="number">12</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">number指定在队列可以同时存在的最大请求数</span><br><span class="line">如果队列已满，或者在 timeout 参数指定的时间段内无法选择传递请求的服务器，则会向客户端返回 <span class="number">502</span> (Bad Gateway) 错误。</span><br></pre></td></tr></table></figure><h3 id="简单反向代理示例"><a href="#简单反向代理示例" class="headerlink" title="简单反向代理示例"></a>简单反向代理示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器，本次用阿里云服务器</span></span><br><span class="line"><span class="comment">#配置Nginx server</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /proxy/ &#123;</span><br><span class="line">                <span class="attribute">root</span> /var/www/html;</span><br><span class="line">                <span class="attribute">index</span> proxy.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">nginx</span> -t <span class="comment">#测试配置文件是否正确</span></span><br><span class="line">nginx -s reload <span class="comment">#重新加载配置寄文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于想测试动态服务器，所以下面做一个简单脚本，实现简易动态服务</span></span><br><span class="line">cd /var/www/html</span><br><span class="line">mkdir proxy</span><br><span class="line">cd proxy</span><br><span class="line"><span class="comment">#编写生成proxy.html动态文本内容脚本random.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">DIR=/var/www/html/proxy</span><br><span class="line">FILE=proxy.html</span><br><span class="line"></span><br><span class="line">while <span class="literal">true</span>;<span class="attribute">do</span></span><br><span class="line">        echo <span class="string">&quot;Application Server,This time create number: <span class="variable">$RANDOM</span>&quot;</span> &gt; <span class="variable">$DIR</span>/<span class="variable">$FILE</span></span><br><span class="line">        sleep <span class="number">1</span> <span class="comment">#睡1秒，防止内容刷新太频繁</span></span><br><span class="line">done;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本，并在后台挂起，注意脚本需要可执行权限</span></span><br><span class="line"><span class="attribute">nohup</span> /var/www/html/proxy/random.sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看proxy.html是否动态生成</span></span><br><span class="line">cat proxy.html</span><br><span class="line">Application Server,This time create number: <span class="number">25253</span></span><br><span class="line">cat proxy.html</span><br><span class="line">Application Server,This time create number: <span class="number">30014</span></span><br><span class="line"><span class="comment">#上面可以看到两次number不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问测试</span></span><br><span class="line">curl <span class="number">127.0.0.1:8080</span>/proxy/</span><br><span class="line">Application Server,This time create number: <span class="number">950</span></span><br><span class="line">curl <span class="number">127.0.0.1:8080</span>/proxy/</span><br><span class="line">Application Server,This time create number: <span class="number">23418</span></span><br><span class="line"><span class="comment">#本地测试ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来配置反向代理服务器，本机Mac</span></span><br><span class="line"><span class="comment">#Nginx配置</span></span><br><span class="line">upstream back_end &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domain隐藏:<span class="number">8080</span> weight=<span class="number">2</span> max_conns=<span class="number">100</span> fail_timeout=<span class="number">10s</span> max_fails=<span class="number">3</span>; <span class="comment">#IP|DOMAIN隐藏，请写上游服务器IP或域名</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">keepalive</span> <span class="number">32</span>;</span><br><span class="line">        <span class="attribute">keepalive_requests</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">keepalive_timeout</span> <span class="number">20s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">89</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /proxy &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://back_end/proxy;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nginx -t #测试配置文件是否正确</span><br><span class="line">nginx -s reload #重新加载配置文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问测试</span></span><br><span class="line">curl 127.0.0.1:89/proxy/</span><br><span class="line">Application Server,This time create number: 25323</span><br><span class="line">curl 127.0.0.1:89/proxy/</span><br><span class="line">Application Server,This time create number: 12020</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试OK，简易反向代理动态服务完成</span></span><br></pre></td></tr></table></figure><h3 id="Nginx代理场景下接受用户请求包体的处理方式"><a href="#Nginx代理场景下接受用户请求包体的处理方式" class="headerlink" title="Nginx代理场景下接受用户请求包体的处理方式"></a>Nginx代理场景下接受用户请求包体的处理方式</h3><h4 id="接收包体的两种方式"><a href="#接收包体的两种方式" class="headerlink" title="接收包体的两种方式"></a>接收包体的两种方式</h4><ul><li>接收完全部包体再发送</li><li>一边接收包体一边发送</li></ul><h4 id="通过proxy-request-buffering指令决定处理方式"><a href="#通过proxy-request-buffering指令决定处理方式" class="headerlink" title="通过proxy_request_buffering指令决定处理方式"></a>通过proxy_request_buffering指令决定处理方式</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_request_buffering</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_request_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">7</span>.<span class="number">11</span>.</span><br></pre></td></tr></table></figure><h5 id="proxy-request-buffering-on"><a href="#proxy-request-buffering-on" class="headerlink" title="proxy_request_buffering on"></a>proxy_request_buffering on</h5><ul><li><p>说明：启用缓冲后，会先从客户端读取整个请求正文，然后再将请求发送到代理服务器</p></li><li><p>适应场景</p><ul><li>吞吐量高</li><li>上游服务并发处理能力低</li></ul></li></ul><h5 id="proxy-request-buffering-off"><a href="#proxy-request-buffering-off" class="headerlink" title="proxy_request_buffering off"></a>proxy_request_buffering off</h5><ul><li>禁用缓冲时，请求正文会在收到后立即发送到代理服务器。在这种情况下，如果 nginx 已经开始发送请求正文，则无法将请求传递给下一个服务器。</li><li>适应场景<ul><li>更及时响应</li><li>减少Nginx磁盘IO</li></ul></li></ul><h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">client_max_body_size</span> size;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">1m</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">设置客户端请求正文的最大允许大小。</span><br><span class="line">如果请求中的大小超过配置的值，则会向客户端返回 413（请求实体太大）错误。请注意，浏览器无法正确显示此错误。</span><br><span class="line"></span><br><span class="line">将size设置为 0 将禁用对客户端请求正文大小的检查。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">client_body_buffer_size</span> size;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">client_body_buffer_size</span> <span class="number">8k</span>|<span class="number">16k</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">设置读取客户端请求正文的缓冲区大小</span><br><span class="line">如果请求正文大于缓冲区，则将整个正文或仅其部分写入临时文件（临时文件目录由client_body_temp_path指定）</span><br><span class="line"></span><br><span class="line">默认情况下，缓冲区大小等于两个内存页。这是x86、其他32位平台和x86-64上的8K。在其他 64 位平台上通常为16K。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">client_body_temp_path</span> path [level1 [level2 [level3]]];</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">client_body_temp_path</span> client_body_temp;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义一个目录，用于存储保存客户端请求正文的临时文件。指定目录下最多可使用三级子目录层次结构。</span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="attribute">client_body_temp_path</span> /spool/nginx/client_temp <span class="number">1</span> <span class="number">2</span>;</span><br><span class="line">临时文件的路径可能像这样：/spool/nginx/client_temp/7/45/00000123457</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">client_body_in_single_buffer</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">client_body_in_single_buffer</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">确定 <span class="attribute">nginx</span> 是否应将整个客户端请求正文保存在单个缓冲区中（连续内存）</span><br><span class="line">使用 <span class="variable">$request_body</span> 变量时建议使用该指令，以节省涉及的复制操作的数量</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">client_body_in_file_only</span> <span class="literal">on</span> | clean | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">client_body_in_file_only</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">确定nginx是否应将整个客户端请求正文保存到文件中。</span><br><span class="line">该指令可以在调试期间使用，或者在使用$request_body_file变量或模块ngx_http_perl_module的$r-&gt;request_body_file方法时使用。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">client_body_timeout</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">client_body_timeout</span> <span class="number">60s</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义读取客户端请求正文的超时时间</span><br><span class="line">超时仅设置为两个连续读取操作之间的一段时间，而不是整个请求正文的传输</span><br><span class="line">如果客户端在此时间内没有传输任何内容，则请求将终止并出现 408（请求超时）错误</span><br></pre></td></tr></table></figure><h5 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#反向代理服务器配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /proxy &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://ip隐藏:8001;</span><br><span class="line"></span><br><span class="line">                <span class="attribute">client_max_body_size</span> <span class="number">10k</span>;</span><br><span class="line">                <span class="comment">#client_body_in_file_only on;</span></span><br><span class="line">                <span class="comment">#client_body_temp_path temp_body_path;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#上游服务器配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8001</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /proxy &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;Proxy OK&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">curl</span> -F <span class="string">&quot;file=<span class="variable">@test</span>.sh&quot;</span> <span class="number">127.0.0.1:90</span>/proxy <span class="comment">#上传文件到指定服务器</span></span><br></pre></td></tr></table></figure><h3 id="Nginx代理场景下如何更改发往上游的请求"><a href="#Nginx代理场景下如何更改发往上游的请求" class="headerlink" title="Nginx代理场景下如何更改发往上游的请求"></a>Nginx代理场景下如何更改发往上游的请求</h3><h4 id="请求行修改指令"><a href="#请求行修改指令" class="headerlink" title="请求行修改指令"></a>请求行修改指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_method</span> method;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">指定在转发到代理服务器的请求中使用的HTTP方法，替换来自客户端请求的方法</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">0</span> | <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">1</span>.<span class="number">4</span>.</span><br><span class="line"></span><br><span class="line">设置代理的HTTP协议版本</span><br><span class="line">默认值为<span class="number">1</span>.<span class="number">0</span>，建议将<span class="number">1</span>.<span class="number">1</span>版本与keepalive连接和NTLM authentication一起使用</span><br></pre></td></tr></table></figure><h4 id="请求头部修改指令"><a href="#请求头部修改指令" class="headerlink" title="请求头部修改指令"></a>请求头部修改指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> field value;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$proxy_host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Connection close;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">允许重新定义或附加字段到传递给代理服务器的请求头</span><br><span class="line">value值可以包含文本、变量及其组合</span><br><span class="line"></span><br><span class="line">当且仅当当前级别上没有定义proxy_set_header指令时，这些指令才从先前的配置级别继承</span><br><span class="line"></span><br><span class="line">如果启用缓存，那么“If-Modified-Since”、“If-Unmodified-Since”、“If-None-Match”、“If-Match”、“Range”、“If-Range”这些头部字段不会从原始请求传递给代理服务器</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">可以像这样传递未更改的Host请求头字段</span><br><span class="line"><span class="attribute">proxy_set_header</span>Host<span class="variable">$http_host</span>;</span><br><span class="line">但是，如果客户端请求头中不存在此字段，则不会传递任何内容。</span><br><span class="line">在这种情况下，最好使用$host变量：如果请求头中该字段存在，它的值等于Host字段的值，如果该字段不存在，等于主服务器的server_name值</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">服务器名称可以和代理服务器的端口一起传递</span><br><span class="line"><span class="attribute">proxy_set_header</span>Host<span class="variable">$host</span>:<span class="variable">$proxy_port</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">如果字段的值为空，那么该字段不会传递给代理服务器</span><br><span class="line"><span class="attribute">proxy_set_header</span> Accept-Encoding <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_pass_request_headers</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_pass_request_headers</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">表示是否将原始请求头中的字段传递给代理服务器；使用了pass_set_header指令，即使该参数设置为off，请求头字段也会传递给代理服务器</span><br></pre></td></tr></table></figure><h4 id="请求包体修改指令"><a href="#请求包体修改指令" class="headerlink" title="请求包体修改指令"></a>请求包体修改指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_set_body</span> value;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line">允许重新定义传递给代理服务器的请求正文。该值可以包含文本、变量及其组合</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_pass_request_body</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_pass_request_body</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line">表示是否将原始请求正文传递给代理服务器；使用了proxy_set_body指令，即使该参数设置为off，请求头字段也会传递给代理服务器</span><br></pre></td></tr></table></figure><h4 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8001</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /proxy &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;请求行</span></span><br><span class="line"><span class="string">request_method: <span class="variable">$request_method</span></span></span><br><span class="line"><span class="string">uri: <span class="variable">$uri</span></span></span><br><span class="line"><span class="string">scheme: <span class="variable">$scheme</span></span></span><br><span class="line"><span class="string">request: <span class="variable">$request</span></span></span><br><span class="line"><span class="string">请求头</span></span><br><span class="line"><span class="string">http_test: <span class="variable">$http_test</span></span></span><br><span class="line"><span class="string">content_length: <span class="variable">$content_length</span></span></span><br><span class="line"><span class="string">content_type <span class="variable">$content_type</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#反向代理服务器配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">91</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /proxy &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://IP隐藏:8001;</span><br><span class="line"></span><br><span class="line">                <span class="comment">#proxy_method GET;</span></span><br><span class="line">                <span class="comment">#proxy_http_version 1.1;</span></span><br><span class="line">                <span class="comment">#proxy_set_header test &#x27;test config header set&#x27;;</span></span><br><span class="line">                <span class="comment">#proxy_pass_request_headers off; #不能和proxy_set_header同时出现，否则无效</span></span><br><span class="line">                <span class="comment">#proxy_set_body &quot;OOOOOOOOOOOOOOOOOOOO&quot;;</span></span><br><span class="line">                <span class="comment">#proxy_pass_request_body off; #不能和proxy_set_body同时出现，否则无效</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">curl</span> <span class="number">127.0.0.1:91</span>/proxy -H <span class="string">&quot;test: &#x27;test header&#x27;&quot;</span> -d <span class="string">&quot;name=123&quot;</span> <span class="comment">#-H 设置request header -d 设置HTTP POST data</span></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">请求行</span><br><span class="line">request_method: POST</span><br><span class="line">uri: /proxy</span><br><span class="line">scheme: http</span><br><span class="line">request: POST /proxy HTTP/<span class="number">1</span>.<span class="number">0</span></span><br><span class="line">请求头</span><br><span class="line">http_test: test config header set</span><br><span class="line">host: <span class="number">106.14.248.117:8001</span></span><br><span class="line">content_length: <span class="number">8</span></span><br><span class="line">content_type application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line"><span class="comment">#上游服务器使用tcpdump抓包，查看body信息</span></span><br><span class="line">tcpdump -i eth0 port <span class="number">8001</span> -A</span><br></pre></td></tr></table></figure><h3 id="Nginx与上游服务器建立连接细节"><a href="#Nginx与上游服务器建立连接细节" class="headerlink" title="Nginx与上游服务器建立连接细节"></a>Nginx与上游服务器建立连接细节</h3><img src="/load_images/nginx_reverse_proxy7.png" alt="img" style="zoom:33%;" /><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><ul><li>客户端到Nginx</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br></pre></td></tr></table></figure><ul><li>Nginx到上游服务</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">keepalive</span> <span class="number">32</span>;</span><br><span class="line"><span class="attribute">keepalive_requests</span> <span class="number">100</span>;</span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">60s</span>;</span><br></pre></td></tr></table></figure><h4 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> <span class="number">60s</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义与代理服务器建立连接的超时时间；注意time不能超过75s</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_socket_keepalive</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_socket_keepalive</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">15</span>.<span class="number">6</span>.</span><br><span class="line"></span><br><span class="line">为到代理服务器的传出连接配置“TCP keepalive”行为；即应用层复用TCP层的长连接</span><br><span class="line">默认情况下，操作系统的设置对套接字有效；</span><br><span class="line">如果该指令设置为值“<span class="literal">on</span>”，则为套接字打开SO_KEEPALIVE套接字选项</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_send_timeout</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_send_timeout</span> <span class="number">60s</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">设置将请求传输到代理服务器的超时时间</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_ignore_client_abort</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_ignore_client_abort</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">确定当客户端关闭连接而不等待响应时是否应关闭与代理服务器的连接<span class="attribute">I</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;反向代理&quot;&gt;&lt;a href=&quot;#反向代理&quot; class=&quot;headerlink&quot; title=&quot;反向代理&quot;&gt;&lt;/a&gt;反向代理&lt;/h3&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://codeman.club/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://codeman.club/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx（持续更新）</title>
    <link href="https://codeman.club/nginx/nginx/"/>
    <id>https://codeman.club/nginx/nginx/</id>
    <published>2022-03-12T09:01:31.000Z</published>
    <updated>2022-11-07T02:49:14.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx处理请求的过程"><a href="#Nginx处理请求的过程" class="headerlink" title="Nginx处理请求的过程"></a>Nginx处理请求的过程</h3><span id="more"></span><img src="/load_images/nginx2.png" alt="img" style="zoom:33%;" /><h3 id="三个常见的应用场景"><a href="#三个常见的应用场景" class="headerlink" title="三个常见的应用场景"></a>三个常见的应用场景</h3><ul><li>静态资源服务（Web Server）</li><li>反向代理服务</li><li>API服务</li></ul><h3 id="Nginx的核心优势"><a href="#Nginx的核心优势" class="headerlink" title="Nginx的核心优势"></a>Nginx的核心优势</h3><ul><li>高并发、高性能</li><li>扩展性好（模块化设计）</li><li>异步非阻塞的事件驱动模型</li></ul><h3 id="Nginx进程"><a href="#Nginx进程" class="headerlink" title="Nginx进程"></a>Nginx进程</h3><h4 id="进程结构图-多进程结构"><a href="#进程结构图-多进程结构" class="headerlink" title="进程结构图-多进程结构"></a>进程结构图-多进程结构</h4><img src="/load_images/nginx3.png" alt="img" style="zoom:33%;" /><p>多进程之间通过共享内存进行通信</p><h4 id="使用信号量管理Nginx进程"><a href="#使用信号量管理Nginx进程" class="headerlink" title="使用信号量管理Nginx进程"></a>使用信号量管理Nginx进程</h4><h5 id="常用信号量（kill-l查看信号量）"><a href="#常用信号量（kill-l查看信号量）" class="headerlink" title="常用信号量（kill -l查看信号量）"></a>常用信号量（kill -l查看信号量）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SIGCHLD kill -17 $PID</span><br><span class="line">SIGQUIT kill -3 $PID</span><br><span class="line">SIFTERM kill -15 $PID | kill $PID</span><br><span class="line">SIGKILL kill -9 $PID</span><br><span class="line">SIGHUP  kill -1 $PID #重读配置文件</span><br><span class="line">SIGUSR1 kill -10 $PID #重新打开日志文件</span><br><span class="line">SIGUSR2 kill -12 $PID</span><br><span class="line">SIGWINCH kill -28 $PID</span><br></pre></td></tr></table></figure><h5 id="master进程"><a href="#master进程" class="headerlink" title="master进程"></a>master进程</h5><img src="/load_images/nginx4.png" alt="img" style="zoom:33%;" /><h5 id="worker进程（不建议直接对work进程发送信号）"><a href="#worker进程（不建议直接对work进程发送信号）" class="headerlink" title="worker进程（不建议直接对work进程发送信号）"></a>worker进程（不建议直接对work进程发送信号）</h5><img src="/load_images/nginx5.png" alt="img" style="zoom:33%;" /><h5 id="命令行（命令行的原理也是向master发送信号量实现的）"><a href="#命令行（命令行的原理也是向master发送信号量实现的）" class="headerlink" title="命令行（命令行的原理也是向master发送信号量实现的）"></a>命令行（命令行的原理也是向master发送信号量实现的）</h5><img src="/load_images/nginx6.png" alt="img" style="zoom:33%;" /><h5 id="发送信号量管理进程"><a href="#发送信号量管理进程" class="headerlink" title="发送信号量管理进程"></a>发送信号量管理进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止nginx</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line">kill -s SIGTERM master_pid #mac中kill -TERM master_pid</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新读取配置文件</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line">kill -s SIGHUP master_pid #mac中 -HUP</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">杀死worker进程(之后master进程会重新启动一个worker进程)</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line">kill -s SIGTERM worker_pid</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><h5 id="命令行管理nginx进程"><a href="#命令行管理nginx进程" class="headerlink" title="命令行管理nginx进程"></a>命令行管理nginx进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -h</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-s signal     : send signal to a master process: stop, quit, reopen, reload</span></span><br><span class="line">nginx -s [stop, quit, reopen, reload] #reopen重新打开日志文件 reload重载配置文件</span><br></pre></td></tr></table></figure><h5 id="reload重载配置文件的流程"><a href="#reload重载配置文件的流程" class="headerlink" title="reload重载配置文件的流程"></a>reload重载配置文件的流程</h5><ol><li><strong>向master进程发送HUP信号（reload命令）</strong></li><li><strong>master进程检查配置语法是否正确</strong></li><li><strong>master进程打开监听端口（如果配置文件端口变动）</strong></li><li><strong>master进程使用新的配置文件启动新的worker子进程</strong></li><li><strong>master进程向老的worker子进程发送QUIT信号</strong></li><li><strong>旧的worker进程关闭监听句柄，处理完当前连接后关闭进程</strong></li></ol><img src="/load_images/nginx7.png" alt="img" style="zoom:33%;" /><h3 id="Nginx热部署"><a href="#Nginx热部署" class="headerlink" title="Nginx热部署"></a>Nginx热部署</h3><p><strong>在不中断当前业务的前提下，对nginx进行平滑升级</strong></p><h4 id="热升级流程"><a href="#热升级流程" class="headerlink" title="热升级流程"></a>热升级流程</h4><ol><li><strong>将旧的nginx文件替换成新编译的nginx文件（目录结构要相同）</strong></li><li><strong>向master进程发送USR2信号</strong></li><li><strong>master进程修改pid文件，从nginx.pid加后缀变为nginx.pid.oldbin</strong></li><li><strong>master进程用新的nginx文件启动新master进程（这时候旧master和新master并存，两者都可以接受处理用户请求）</strong></li><li><strong>向旧的master进程发送WINCH信号，目的是退出旧的worker子进程，不退出旧master进程的目的是为了回滚情形</strong></li><li><strong>新功能测试没问题之后，向旧master发送QUIT型号，退出。这时候会自动删除3步骤生成的oldbin后缀名文件</strong></li><li><strong>如果需要回滚：向旧master发送HUP，向新的master发送QUIT</strong></li></ol><img src="/load_images/nginx8.png" alt="img" style="zoom:33%;" /><h3 id="Nginx模块化管理机制"><a href="#Nginx模块化管理机制" class="headerlink" title="Nginx模块化管理机制"></a>Nginx模块化管理机制</h3><h4 id="模块结构图"><a href="#模块结构图" class="headerlink" title="模块结构图"></a>模块结构图</h4><img src="/load_images/nginx9.png" alt="img" style="zoom:33%;" /><h4 id="模块体系结构"><a href="#模块体系结构" class="headerlink" title="模块体系结构"></a>模块体系结构</h4><img src="/load_images/nginx10.png" alt="img" style="zoom:33%;" /><h3 id="编译安装Nginx"><a href="#编译安装Nginx" class="headerlink" title="编译安装Nginx"></a>编译安装Nginx</h3><h4 id="常见配置参数"><a href="#常见配置参数" class="headerlink" title="常见配置参数"></a>常见配置参数</h4><table><thead><tr><th align="center">参数</th><th>含义</th></tr></thead><tbody><tr><td align="center">–prefix</td><td>指定安装的目录</td></tr><tr><td align="center">–user</td><td>运行nginx的worker子进程的属主 属主需要提前设置好</td></tr><tr><td align="center">–group</td><td>运行nginx的worker子进程的属组 属组需要提前设置好</td></tr><tr><td align="center">–pid-path</td><td>存放进程运行的pid文件的路径</td></tr><tr><td align="center">–conf-path</td><td>配置文件nginx.conf的存放路径</td></tr><tr><td align="center">–error-log-path</td><td>错误日志error.log的存放路径</td></tr><tr><td align="center">–http-log-path</td><td>访问日志access.log的存放路径</td></tr><tr><td align="center">–with-pcre</td><td>pcre库的存放路径，正则表达式会用到</td></tr><tr><td align="center">–with-zlib</td><td>zlib库的存放路径，gzip模块会用到</td></tr></tbody></table><h4 id="内置参数默认原则"><a href="#内置参数默认原则" class="headerlink" title="内置参数默认原则"></a>内置参数默认原则</h4><p>–with 显示加上，默认不内置</p><p>–without 显示去掉，默认内置</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><img src="/load_images/nginx11.png" alt="img" style="zoom:33%;" /><h4 id="虚拟主机分类"><a href="#虚拟主机分类" class="headerlink" title="虚拟主机分类"></a>虚拟主机分类</h4><ul><li><strong>基于多IP的虚拟主机</strong></li><li><strong>基于多端口的虚拟主机</strong></li><li><strong>基于域名的虚拟主机</strong></li></ul><h5 id="基于多IP"><a href="#基于多IP" class="headerlink" title="基于多IP"></a>基于多IP</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改网卡接口绑定的IP地址</span></span><br><span class="line"><span class="comment">#重启网络</span></span><br><span class="line"><span class="comment">#修改nginx配置文件server段listen 监听对应ip和端口</span></span><br><span class="line">server&#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">192.168.184.240</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">192.168.184.241</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#nginx -t查看配置文件是有报错，之后重启nginx</span></span><br><span class="line"><span class="comment">#浏览器访问对应ip和端口看下效果</span></span><br></pre></td></tr></table></figure><h5 id="基于多端口"><a href="#基于多端口" class="headerlink" title="基于多端口"></a>基于多端口</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">root</span> html/virtual_host1;</span><br><span class="line"><span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">root</span> html/virtual_host2;</span><br><span class="line"><span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx -t查看配置文件是有报错，之后重启nginx</span></span><br></pre></td></tr></table></figure><h5 id="基于域名的虚拟机"><a href="#基于域名的虚拟机" class="headerlink" title="基于域名的虚拟机"></a>基于域名的虚拟机</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> local.test1.com;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">root</span> html/domain_host1;</span><br><span class="line"><span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> local.test2.com;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">root</span> html/domain_host2;</span><br><span class="line"><span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件main段核心参数用法"><a href="#配置文件main段核心参数用法" class="headerlink" title="配置文件main段核心参数用法"></a>配置文件main段核心参数用法</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> USERNAME [GROUP]</span><br><span class="line"><span class="comment">#指定运行nginx的worker子进程的属主和属组，其中属组可以不指定</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">user nginx nginx;</span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span> DIR</span><br><span class="line"><span class="comment">#指定运行nginx的master主进程的pid文件存放路径</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">pid /usr/local/var/run/nginx.pid</span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile number</span><br><span class="line"><span class="comment">#指定worker子进程可以打开的最大文件句柄数</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">worker_rlimit_nofile <span class="number">20480</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_rlimit_core</span> size</span><br><span class="line"><span class="comment">#指定worker子进程异常终止后的core文件，用于记录分析问题</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">worker_rlimit_core <span class="number">50M</span>;</span><br><span class="line"><span class="attribute">working_directory</span> /usr/local/var/log/nginx/tmp; <span class="comment">#此目录对nginx要有写权限</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_processes</span> number | auto;</span><br><span class="line"><span class="comment">#指定nginx启动的worker子进程数量</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span>;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> cpumask1 cpumask2...</span><br><span class="line">worker_cpu_affinity auto [cpumask];</span><br><span class="line"><span class="comment">#将每个worker子进程与CPU物理核心绑定</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> <span class="number">0001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1000</span>;<span class="comment">#4个物理核心，4个worker子进程</span></span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> <span class="number">00000001</span> <span class="number">00000010</span> <span class="number">00001000</span> <span class="number">00010000</span> <span class="number">00100000</span> <span class="number">01000000</span> <span class="number">10000000</span>; <span class="comment">#8个物理核心，8个worker子进程</span></span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> <span class="number">01</span> <span class="number">10</span> <span class="number">01</span> <span class="number">10</span>; <span class="comment">#2个物理核心，4个子进程</span></span><br><span class="line"><span class="comment">#备注：将每个worker子进程与特定CPU物理核心绑定，优势在于：避免同一个worker子进程在不同的CPU核心上切换，缓存失效，降低性能；其实并不能真正的避免进程切换</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_priority</span> number</span><br><span class="line"><span class="comment">#执行worker子进程的nice值，以调整运行nginx的优先级，通常设定为负值，以优先调用nginx</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">worker_priority -<span class="number">10</span>; <span class="comment">#优先级计算120-10=110，worker子进程的优先级为110</span></span><br><span class="line"><span class="comment">#备注：Linux默认进程的优先级值是120，值越小越有限；nice设定范围为-20到+19</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_shutdown_timeout</span> time</span><br><span class="line"><span class="comment">#指定worker子进程优雅退出时的超时时间</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">worker_shutdown_timeout <span class="number">5s</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">timer_resolution</span> time</span><br><span class="line"><span class="comment">#worker子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">timer_resolution 100ms;</span><br><span class="line"></span><br><span class="line"><span class="attribute">daemon</span> <span class="literal">on</span>|<span class="literal">off</span></span><br><span class="line"><span class="comment">#设定nginx的运行方式，前台还是后台，前台用户调试，后台用于生产</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">daemon <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">lock_file</span> file</span><br><span class="line"><span class="comment">#负载均衡互斥锁文件存放路径</span></span><br><span class="line"><span class="comment">#默认配置：lock_file logs/nginx.lock</span></span><br><span class="line"><span class="comment">#推荐配置：lock_file logs/nginx.lock</span></span><br></pre></td></tr></table></figure><h5 id="worker子进程与CPU核心绑定"><a href="#worker子进程与CPU核心绑定" class="headerlink" title="worker子进程与CPU核心绑定"></a>worker子进程与CPU核心绑定</h5><img src="/load_images/nginx12.png" alt="img" style="zoom:33%;" /><h5 id="客户端请求处理流程"><a href="#客户端请求处理流程" class="headerlink" title="客户端请求处理流程"></a>客户端请求处理流程</h5><img src="/load_images/nginx13.png" alt="img" style="zoom:33%;" /><h5 id="配置错误解决"><a href="#配置错误解决" class="headerlink" title="配置错误解决"></a>配置错误解决</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] getpwnam(&quot;nginx&quot;) failed in /usr/local/etc/nginx/nginx.conf:2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置文件中user指定的属主，属组在系统中没有，需要创建</span></span><br></pre></td></tr></table></figure><h4 id="配置文件event段核心参数用法"><a href="#配置文件event段核心参数用法" class="headerlink" title="配置文件event段核心参数用法"></a>配置文件event段核心参数用法</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">use</span> method</span><br><span class="line"><span class="comment">#nginx使用何种事件驱动模型 method值：select、poll、kqueue、epoll、/dev/poll、eventport</span></span><br><span class="line"><span class="comment">#默认配置：无</span></span><br><span class="line"><span class="comment">#推荐不指定，让nginx自己选择</span></span><br><span class="line"></span><br><span class="line">worker_connections number</span><br><span class="line"><span class="comment">#worker子进程能够处理的最大并发连接数</span></span><br><span class="line"><span class="comment">#默认配置：worker_connections 1024</span></span><br><span class="line"><span class="comment">#推荐配置；worker_connections 65535/worker_processes | 65535</span></span><br><span class="line"></span><br><span class="line">accept_mutex <span class="literal">on</span> | <span class="literal">off</span></span><br><span class="line"><span class="comment">#是否打开负载均衡互斥锁</span></span><br><span class="line"><span class="comment">#默认配置 off</span></span><br><span class="line"><span class="comment">#推荐配置 on 开启时，后台会生成一个负载均衡锁，负载均衡锁会轮流的将请求由master process发送给子进程</span></span><br><span class="line"><span class="comment">#如果accept_mutex的值被设为off，那么当有请求需要处理时，所有的worker进程都会从waiting状态中唤醒，</span></span><br><span class="line"><span class="comment">#但是只有一个worker进程能处理请求，这造成了thundering herd现象，这个现象每一秒钟会发生多次。</span></span><br><span class="line"><span class="comment">#它使服务器的性能下降，因为所有被唤醒的worker进程在重新进入waiting状态前会占用一段CPU时间</span></span><br><span class="line"></span><br><span class="line">accept_mutex_delay time</span><br><span class="line"><span class="comment">#需要开启accept_mutex才会生效</span></span><br><span class="line"><span class="comment">#默认配置 accept_mutex_delay 500ms</span></span><br><span class="line"><span class="comment">#推荐配置 accept_mutex_delay 200ms</span></span><br><span class="line"><span class="comment">#当accept_mutex功能启用后，只有一个持有mutex锁的worker进程会接受并处理请求，其他worker进程等待。</span></span><br><span class="line"><span class="comment">#accept_mutex_delay指定的时间就是这些worker进程的等待时间，过了等待时间下一个worker进程便取得mutex锁，处理请求。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">muti_accept <span class="literal">on</span> | <span class="literal">off</span></span><br><span class="line"><span class="comment">#worker子进程可以接收的新连接个数</span></span><br><span class="line"><span class="comment">#默认配置：multi_accept off</span></span><br><span class="line"><span class="comment">#推荐配置：multi_accept on 打开后，worker进程会一次性接受监听队列中的所有请求，然后处理</span></span><br><span class="line"><span class="comment">#如果web服务器面对的是一个持续的请求流，那么启用multi_accept可能会造成worker进程一次接受的请求大于worker_connections指定可以接受的请求数。</span></span><br><span class="line"><span class="comment">#这就是overflow，这个overflow会造成性能损失，overflow这部分的请求不会受到处理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h4><h5 id="指令的用法"><a href="#指令的用法" class="headerlink" title="指令的用法"></a>指令的用法</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要在hosts文件中配置DNS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#语法结构</span></span><br><span class="line"><span class="attribute">server_name</span> name1 name2 name3 ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例1 精确匹配</span></span><br><span class="line"><span class="attribute">server_name</span> local.test.com;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2</span></span><br><span class="line"><span class="attribute">server_name</span> <span class="regexp">*.test.com</span>; <span class="comment">#左侧通配符匹配</span></span><br><span class="line"><span class="attribute">server_name</span> <span class="regexp">local.test.*</span>; <span class="comment">#右侧通配符匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3</span></span><br><span class="line"><span class="attribute">server_name</span> local.test.com <span class="regexp">*.test.com</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例4</span></span><br><span class="line"><span class="attribute">server_name</span> ~^local\.test\..*$ <span class="comment">#正则表达式匹配</span></span><br></pre></td></tr></table></figure><h5 id="指令用法优先级"><a href="#指令用法优先级" class="headerlink" title="指令用法优先级"></a>指令用法优先级</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多域名如何匹配</span></span><br><span class="line">server&#123;</span><br><span class="line"><span class="attribute">server_name</span> local.test.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line"><span class="attribute">server_name</span> <span class="regexp">*.test.com</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line"><span class="attribute">server_name</span> <span class="regexp">local.test.*</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line"><span class="attribute">server_name</span> ~^local\.test\..*$;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#问题：访问local.test.com，这几个server都能够匹配，那么到底访问哪个server呢？</span></span><br><span class="line"><span class="comment">#这就涉及到指令写法的优先级</span></span><br><span class="line"><span class="comment">#优先级从高到底依次为：精确匹配、左侧通配符匹配、右侧通配符匹配、正则表达式匹配</span></span><br></pre></td></tr></table></figure><h4 id="root和alias"><a href="#root和alias" class="headerlink" title="root和alias"></a>root和alias</h4><h5 id="root指令"><a href="#root指令" class="headerlink" title="root指令"></a>root指令</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root</span> path;</span><br><span class="line"><span class="comment">#默认值：root html;</span></span><br><span class="line"><span class="comment">#上下文:http, server, location, if in location</span></span><br></pre></td></tr></table></figure><h5 id="alias指令"><a href="#alias指令" class="headerlink" title="alias指令"></a>alias指令</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">alias</span> path;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：location</span></span><br></pre></td></tr></table></figure><h5 id="root和alias的相同点和区别"><a href="#root和alias的相同点和区别" class="headerlink" title="root和alias的相同点和区别"></a>root和alias的相同点和区别</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#相同点</span></span><br><span class="line">URI到磁盘文件的映射</span><br><span class="line"><span class="comment">#区别</span></span><br><span class="line">root会将定义路径与URI叠加；alias则只取定义路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="section">location</span> /picture &#123;</span><br><span class="line"><span class="attribute">root</span> /usr/local/Celler/nginx/<span class="number">1</span>.<span class="number">23</span>.<span class="number">1</span>/html/picture;</span><br><span class="line">&#125;</span><br><span class="line">客户端请求local.test.com/picture/1.jpg，则对应磁盘映射路径/usr/local/Celler/nginx/1.23.1/html/picture/picture/1.<span class="attribute">jpg</span> </span><br><span class="line"><span class="comment">#root会把URI叠加上去，所以root只需要写成root /usr/local/Celler/nginx/1.23.1/html即可</span></span><br><span class="line"><span class="comment">#可以通过error.log查看错误信息</span></span><br><span class="line"></span><br><span class="line">location /picture &#123;</span><br><span class="line"><span class="attribute">alias</span> /usr/local/Celler/nginx/<span class="number">1</span>.<span class="number">23</span>.<span class="number">1</span>/html/picture/; <span class="comment">#使用alias，末尾一定加/</span></span><br><span class="line">&#125;</span><br><span class="line">客户端请求local.test.com/picture/1.jpg，则对应磁盘映射路径/usr/local/Celler/nginx/1.23.1/html/picture/1.<span class="attribute">jpg</span> <span class="comment">#alias不会把URI叠加上去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意事项</span></span><br><span class="line">使用alias，末尾一定加/</span><br><span class="line">alias只能位于location块中</span><br></pre></td></tr></table></figure><h4 id="location基础用法"><a href="#location基础用法" class="headerlink" title="location基础用法"></a>location基础用法</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法结构</span></span><br><span class="line"><span class="section">location</span> [ = | <span class="regexp">~ |</span> <span class="regexp">~* |</span><span class="regexp"> ^~</span> ] uri &#123; ... &#125;</span><br><span class="line"><span class="section">location</span> <span class="variable">@name</span> &#123; ... &#125;</span><br><span class="line"><span class="comment">#上下文：server, location</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>匹配规则</th><th>含义</th><th>示例</th><th>优先级</th></tr></thead><tbody><tr><td>&#x3D;</td><td>精确匹配</td><td>location &#x3D; &#x2F;images&#x2F;{ … }</td><td>最高</td></tr><tr><td>^~</td><td>匹配到即停止搜索</td><td>location ^~ &#x2F;images&#x2F; { … }</td><td></td></tr><tr><td>~</td><td>正则匹配，区分大小写</td><td>location ~ .(jpg|gif)$ { … }</td><td></td></tr><tr><td>~*</td><td>正则匹配，不区分大小写</td><td>location ~* .{jpg|gif}$ { … }</td><td></td></tr><tr><td>不带任何符号</td><td></td><td>location &#x2F; { … }</td><td>最低</td></tr></tbody></table><h5 id="官网示例"><a href="#官网示例" class="headerlink" title="官网示例"></a>官网示例</h5><p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location">http://nginx.org/en/docs/http/ngx_http_core_module.html#location</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Let’<span class="attribute">s</span> illustrate the above by an example:</span><br><span class="line"></span><br><span class="line">location = / &#123;</span><br><span class="line">    [ <span class="attribute">configuration</span> A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    [ <span class="attribute">configuration</span> B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">    [ <span class="attribute">configuration</span> C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location<span class="regexp"> ^~</span> /images/ &#123;</span><br><span class="line">    [ <span class="attribute">configuration</span> D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location <span class="regexp">~* \.(gif|jpg|jpeg)$</span> &#123;</span><br><span class="line">    [ <span class="attribute">configuration</span> E ]</span><br><span class="line">&#125;</span><br><span class="line">The “/” request will match configuration A, <span class="comment">#A和B都能匹配到，但是=的优先级高，所以最终匹配的是A</span></span><br><span class="line">the “/index.html” request will match configuration B, <span class="comment">#A和B都能匹配到，但是A是完全精确匹配，只有在完全匹配/的时候才会走A，所以这里匹配的是B</span></span><br><span class="line">the “/documents/document.html” request will match configuration C, <span class="comment">#B和C都能匹配到，但是C匹配的更精准</span></span><br><span class="line">the “/images/<span class="number">1</span>.gif” request will match configuration D, <span class="comment">#D和E都能匹配到，但是^~优先级比~*高，所以匹配D</span></span><br><span class="line">and the “/documents/<span class="number">1</span>.jpg” request will match configuration E. <span class="comment">#C和E都能匹配到，但是~*优先级比E高，所以匹配E</span></span><br><span class="line"><span class="comment">#在都能匹配到的情况下，最终匹配优先级高的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">/test/ &#123; ... &#125;和^~ /test/ &#123; ... &#125; 这两种写法同时出现会存在冲突，nginx认为这两个配置是重复的</span><br></pre></td></tr></table></figure><h5 id="location中URL结尾的反斜线"><a href="#location中URL结尾的反斜线" class="headerlink" title="location中URL结尾的反斜线"></a>location中URL结尾的反斜线</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不带/</span></span><br><span class="line"><span class="section">location</span> /test &#123; ... &#125; </span><br><span class="line"><span class="comment">#处理规则：</span></span><br><span class="line"><span class="comment">#先将test作为一个目录，去root定义的目录找test文件夹</span></span><br><span class="line"><span class="comment">#test目录存在：根据index配置去找对应文件，如果index没有配置，默认去找index.html；找不到对应文件，返回403</span></span><br><span class="line"><span class="comment">#test目录不存在：将test作为一个文件，如果文件存在，将文件内容返回，Chrome可能存在问题，可以换个浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /test/ &#123; ... &#125; </span><br><span class="line"><span class="comment">#处理规则：</span></span><br><span class="line"><span class="comment">#直接将test作为一个目录，去root定义的目录找test文件夹，如果没有这个文件夹，不会将test作为文件处理，返回404</span></span><br><span class="line"><span class="comment">#test目录存在：根据index配置去找对应文件，如果index没有配置，默认去找index.html；找不到对应文件，返回403</span></span><br></pre></td></tr></table></figure><h4 id="stub-status模块的用法"><a href="#stub-status模块的用法" class="headerlink" title="stub_status模块的用法"></a>stub_status模块的用法</h4><p><strong>nginx监控页面的模块</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法结构</span></span><br><span class="line">stub_status;</span><br><span class="line"><span class="comment">#低于1.7.5版本：stub_status on;</span></span><br><span class="line"><span class="comment">#默认值:—</span></span><br><span class="line"><span class="comment">#上下文:server, location</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="section">location</span> /uri &#123; <span class="comment">#uri要具有保密性，防止暴露服务器信息</span></span><br><span class="line">stub_status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：要想使用此指令，需要在编译Nginx的时候指定-with-http_stub_status_module</span></span><br></pre></td></tr></table></figure><h5 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h5><table><thead><tr><th>状态项</th><th>含义</th></tr></thead><tbody><tr><td>Active Connections</td><td>活跃的连接数量</td></tr><tr><td>accepts</td><td>接受的客户端连接总数量</td></tr><tr><td>handled</td><td>处理的客户端连接总数量</td></tr><tr><td>requests</td><td>客户端总的请求数量</td></tr><tr><td>Reading</td><td>读取客户端的连接数</td></tr><tr><td>Writing</td><td>相应数据到客户端的连接数</td></tr><tr><td>Waiting</td><td>空闲客户端请求连接数量</td></tr></tbody></table><h5 id="内嵌变量"><a href="#内嵌变量" class="headerlink" title="内嵌变量"></a>内嵌变量</h5><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>$connections_active</td><td>同Active connections值</td></tr><tr><td>$connections_reading</td><td>同Reading值</td></tr><tr><td>$connections_writing</td><td>同Writing值</td></tr><tr><td>$connections_waiting</td><td>同Waiting值</td></tr></tbody></table><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> local.test.com;</span><br><span class="line"><span class="attribute">root</span> html;</span><br><span class="line"><span class="section">location</span> /stub_status &#123;</span><br><span class="line">stub_status;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#浏览器访问local.test.com/stub_status</span></span><br><span class="line"><span class="comment">#页面结果展示（刷新页面数据会变动）：</span></span><br><span class="line"><span class="attribute">Active</span> connections: <span class="number">2</span> </span><br><span class="line">server accepts handled requests</span><br><span class="line"> <span class="number">26</span> <span class="number">26</span> <span class="number">81</span> </span><br><span class="line">Reading: <span class="number">0</span> Writing: <span class="number">1</span> Waiting: <span class="number">1</span> </span><br></pre></td></tr></table></figure><h3 id="HTTP核心模块"><a href="#HTTP核心模块" class="headerlink" title="HTTP核心模块"></a>HTTP核心模块</h3><h4 id="connection和request"><a href="#connection和request" class="headerlink" title="connection和request"></a>connection和request</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本含义</span></span><br><span class="line">connection是连接，即常说的tcp连接，三次握手，状态机</span><br><span class="line">request是请求，例如http请求，无状态协议</span><br><span class="line">request是必须建立在connection之上</span><br></pre></td></tr></table></figure><h4 id="limit-conn限制connection的模块"><a href="#limit-conn限制connection的模块" class="headerlink" title="limit_conn限制connection的模块"></a>limit_conn限制connection的模块</h4><ul><li>作用是限制客户端并发连接数</li><li>默认编译进Nginx，通过–without-http_limit_conn_module禁用</li><li>使用共享内存，对所有worker子进程生效</li></ul><h5 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h5><ul><li><strong>limit_conn_zone</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">limit_conn_zone</span> key zone=name:size;</span><br><span class="line"><span class="comment">#说明：key 可以是文本、变量或文本与变量的组合；name需要全局唯一。</span></span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http</span></span><br><span class="line"><span class="comment">#官网示例：对用户IP进行并发计数，将计数内存区命名为addr，设置计数内存区大小为10MB</span></span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=addr:<span class="number">10m</span>;</span><br><span class="line"><span class="comment">#官网示例说明</span></span><br><span class="line"><span class="attribute">Note</span> that instead of <span class="variable">$remote_addr</span>, the <span class="variable">$binary_remote_addr</span> variable is used here. </span><br><span class="line">The <span class="variable">$remote_addr</span> variable’s size can vary from <span class="number">7</span> to <span class="number">15</span> bytes. The stored state occupies either <span class="number">32</span> or <span class="number">64</span> bytes of memory <span class="literal">on</span> <span class="number">32</span>-bit platforms and always <span class="number">64</span> bytes <span class="literal">on</span> <span class="number">64</span>-bit platforms. </span><br><span class="line">The <span class="variable">$binary_remote_addr</span> variable’s size is always <span class="number">4</span> bytes for IPv4 addresses or <span class="number">16</span> bytes for IPv6 addresses. The stored state always occupies <span class="number">32</span> or <span class="number">64</span> bytes <span class="literal">on</span> <span class="number">32</span>-bit platforms and <span class="number">64</span> bytes <span class="literal">on</span> <span class="number">64</span>-bit platforms. </span><br><span class="line">One megabyte(兆字节) zone can keep about <span class="number">32</span> thousand <span class="number">32</span>-byte states or about <span class="number">16</span> thousand <span class="number">64</span>-byte states. If the zone storage is exhausted, the server will return the <span class="literal">error</span> to all further requests.</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例：限制同一server最大并发数</span></span><br><span class="line">limit_conn_zone <span class="variable">$server_name</span> zone=perserver:<span class="number">10m</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>limit_conn_status</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">limit_conn_status</span> code;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">limit_conn_status</span> <span class="number">503</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="comment">#说明：指定nginx回复那些被禁用的连接请求时的状态码，默认情况下是503（Service Unavailable 服务不可用）。当限制行为发生的时候，返回的状态码</span></span><br><span class="line"><span class="comment">#状态码必须在400到599之间</span></span><br></pre></td></tr></table></figure><ul><li><strong>limit_conn_log_level</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">limit_conn_log_level</span> <span class="literal">info</span> | <span class="literal">notice</span> | <span class="literal">warn</span> | <span class="literal">error</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">limit_conn_log_level</span> <span class="literal">error</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#说明：为服务器限制连接数的情况设置所需的日志记录级别。当限制行为发生的时候，记录日志。</span></span><br></pre></td></tr></table></figure><ul><li><strong>limit_conn</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">limit_conn</span> zone number;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="comment">#Sets the shared memory zone and the maximum allowed number of connections for a given key value. When this limit is exceeded, the server will return the error in reply to a request</span></span><br><span class="line"><span class="comment">#示例：每个IP地址，一次只允许一个连接</span></span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=addr:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> /download/ &#123;</span><br><span class="line">        <span class="attribute">limit_conn</span> addr <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="limit-req限制request的模块"><a href="#limit-req限制request的模块" class="headerlink" title="limit_req限制request的模块"></a>limit_req限制request的模块</h4><ul><li>用于限制客户端处理请求的平均速率</li><li>默认编译进Nginx，通过–without-http_limit_req_module禁用</li><li>使用共享内存，对所有worker子进程生效</li><li>限流算法：leaky_bucket</li></ul><img src="/load_images/nginx14.png" alt="img" style="zoom: 50%;" /><h5 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h5><ul><li><strong>limit_req_zone</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> key zone=name:size rate=rate [sync];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=1r/s; <span class="comment">#每秒一个请求</span></span><br><span class="line"><span class="comment">#限制客户端请求平均速率为2r/m，每分钟2个请求，即每30秒处理一个请求，不会在第一个30秒内处理两个请求，即使第一个请求很快处理完。</span></span><br></pre></td></tr></table></figure><ul><li><strong>limit_req_status</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">limit_req_status</span> code;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">limit_req_status</span> <span class="number">503</span>;</span><br><span class="line"><span class="comment">#上下文：http、server、location</span></span><br></pre></td></tr></table></figure><ul><li><strong>limit_req_log_level</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">limit_req_log_level</span> <span class="literal">info</span> | <span class="literal">notice</span> | <span class="literal">warn</span> | <span class="literal">error</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">limit_req_log_level</span> <span class="literal">error</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br></pre></td></tr></table></figure><ul><li><strong>limit_req</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">limit_req</span> zone=name [burst=number] [nodelay | delay=number];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="comment">#示例：平均每秒允许不超过1个请求，突发不超过5个请求</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=1r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">error_log</span> logs/one.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> /search/ &#123;</span><br><span class="line"><span class="attribute">limit_req_status</span> <span class="number">504</span>;</span><br><span class="line"><span class="attribute">limit_req_log_level</span> <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">limit_req</span> zone=one burst=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="access模块"><a href="#access模块" class="headerlink" title="access模块"></a>access模块</h4><p>限制特定IP或网段访问</p><h5 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h5><ul><li><strong>allow</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">allow</span> address | CIDR | unix: | all;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location, limit_except</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>deny</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">deny</span> address | CIDR | unix: | all;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location, limit_except</span></span><br></pre></td></tr></table></figure><h5 id="组合示例"><a href="#组合示例" class="headerlink" title="组合示例"></a>组合示例</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">deny</span>  <span class="number">192.168.1.1</span>;</span><br><span class="line">    <span class="attribute">allow</span> <span class="number">192.168.1.0</span>/<span class="number">24</span>; <span class="comment">#除了192.168.1.1以外，都能访问，如果两行互换位置，那么deny不会生效，因为allow的范围包含了192.168.1.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">allow</span> <span class="number">10.1.1.0</span>/<span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">allow</span> <span class="number">2001</span>:0db8::/<span class="number">32</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">deny</span>  all; <span class="comment">#除上面allow的地址以外都拒绝掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Auth-basic模块"><a href="#Auth-basic模块" class="headerlink" title="Auth_basic模块"></a>Auth_basic模块</h4><p>限制特定用户访问</p><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li>基于HTTP Basic Authentication协议进行用户名密码认证</li><li>默认已编译进Nginx，通过–without-http_auth_basic_module禁用</li></ul><h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><ul><li>auth_basic</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">auth_basic</span> string | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">auth_basic</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location, limit_except</span></span><br></pre></td></tr></table></figure><ul><li>auth_basic_user_file</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：auth_basic_user_file file;</span></span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location, limit_except</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#官网说明</span></span><br><span class="line">file为用户名密码保存的文件，file可以是一个变量</span><br><span class="line">file文件内容格式：</span><br><span class="line"><span class="comment"># comment</span></span><br><span class="line">name1:<span class="attribute">password1</span></span><br><span class="line">name2:password2:comment</span><br><span class="line">name3:password3</span><br><span class="line"></span><br><span class="line">The following password types are supported:</span><br><span class="line">· encrypted with the crypt() function; <span class="attribute">can</span> be generated using the “htpasswd” utility from the Apache HTTP Server distribution or the “openssl passwd” command;</span><br><span class="line">· <span class="attribute">hashed</span> with the Apache variant of the MD5-based password algorithm (apr1); <span class="attribute">can</span> be generated with the same tools;</span><br><span class="line">· <span class="attribute">specified</span> by the “&#123;scheme&#125;data” <span class="attribute">syntax</span> (<span class="number">1</span>.<span class="number">0</span>.<span class="number">3</span>+) as described in RFC <span class="number">2307</span>; <span class="attribute">currently</span> implemented schemes include PLAIN (an example one, should not be used), SHA (<span class="number">1</span>.<span class="number">3</span>.<span class="number">13</span>) (plain SHA-<span class="number">1</span> hashing, should not be used) and SSHA (salted SHA-<span class="number">1</span> hashing, used by some software packages, notably OpenLDAP and Dovecot).</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">auth_basic</span>           <span class="string">&quot;closed site&quot;</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> conf/htpasswd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#注意：</span></span><br><span class="line"><span class="comment">#默认去nginx配置文件目录下去找auth_basic_user_file指定的密码文件</span></span><br><span class="line"><span class="comment">#（如mac电脑，去/usr/local/etc/nginx/conf/htpasswd，其中conf/htpasswd是auth_basic_user_file指令指定的）</span></span><br><span class="line"><span class="comment">#除非使用绝对路径指定新目录</span></span><br></pre></td></tr></table></figure><h5 id="生成密码文件工具"><a href="#生成密码文件工具" class="headerlink" title="生成密码文件工具"></a>生成密码文件工具</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#htpasswd</span></span><br><span class="line"><span class="comment">#所属软件包：httpd_tools</span></span><br><span class="line"><span class="comment">#生成新密码文件：</span></span><br><span class="line"><span class="attribute">htpasswd</span> -c encrypt_pass <span class="comment">#encrypt_pass密码文件名</span></span><br><span class="line"><span class="comment">#添加新用户密码：</span></span><br><span class="line">htpasswd -b encrypt_pass mike <span class="number">123456</span> <span class="comment">#向encrypt_pass文件添加新用户密码</span></span><br></pre></td></tr></table></figure><h4 id="auth-request模块"><a href="#auth-request模块" class="headerlink" title="auth_request模块"></a>auth_request模块</h4><h5 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li>基于子请求收到的HTTP响应码做访问控制</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">官网说明</span></span><br><span class="line">If the subrequest returns a 2xx response code, the access is allowed. </span><br><span class="line">If it returns 401 or 403, the access is denied with the corresponding error code. </span><br><span class="line">Any other response code returned by the subrequest is considered an error.</span><br><span class="line"></span><br><span class="line">For the 401 error, the client also receives the “WWW-Authenticate” header from the subrequest response.</span><br></pre></td></tr></table></figure><img src="/load_images/nginx15.png" alt="img" style="zoom:50%;" /><ul><li>默认没有编译进Nginx，通过–with-http_auth_request_module启用</li></ul><h5 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h5><p>根据子请求的结果启用授权，并设置子请求将发送到的URI。</p><ul><li>auth_request</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法auth_request uri | off;</span></span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">auth_request</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br></pre></td></tr></table></figure><ul><li>auth_request_set</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">auth_request_set</span> <span class="variable">$variable</span> value;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br></pre></td></tr></table></figure><h5 id="用法示例-1"><a href="#用法示例-1" class="headerlink" title="用法示例"></a>用法示例</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#官网示例</span></span><br><span class="line"><span class="section">location</span> /private/ &#123;</span><br><span class="line">    <span class="attribute">auth_request</span> /auth;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> = /auth &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/verify;</span><br><span class="line">    <span class="attribute">proxy_pass_request_body</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Content-Length <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Original-URI <span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#本地示例</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">82</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> html;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /oa/ &#123;</span><br><span class="line">    <span class="attribute">auth_request</span> /auth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> = /auth &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;test auth_request&quot;</span>;</span><br><span class="line">    <span class="comment">#return 403;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rewrite模块"><a href="#rewrite模块" class="headerlink" title="rewrite模块"></a>rewrite模块</h4><h5 id="指令-2"><a href="#指令-2" class="headerlink" title="指令"></a>指令</h5><ul><li><strong>return指令</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">return</span> code [text]; <span class="comment">#code为2xx时，text才会在body中返回</span></span><br><span class="line"><span class="attribute">return</span> code URL; <span class="comment">#用于重定向，code为3xx</span></span><br><span class="line"><span class="attribute">return</span> URL; <span class="comment">#URL应以“http://”、“https://”或“$scheme”字符串开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：server, location, if</span></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">停止处理请求，直接向客户端返回响应码或重定向到其他URL（非标准<span class="attribute">code</span> <span class="number">444</span> 关闭连接而不发送响应头）</span><br><span class="line">执行return指令后，location中后续指令将不会被执行</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">location / &#123;</span><br><span class="line">......</span><br><span class="line"><span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#本地示例</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">81</span>;</span><br><span class="line"><span class="attribute">root</span> html;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="comment">#return 200;</span></span><br><span class="line"><span class="comment">#return 200 &quot;sucess&quot;;</span></span><br><span class="line"><span class="comment">#return 302 /test;</span></span><br><span class="line"><span class="attribute">return</span> http://localhost:82/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /test &#123;</span><br><span class="line"><span class="attribute">index</span> test.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">82</span>;</span><br><span class="line"><span class="attribute">root</span> html;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">index</span> index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令行curl http://localhost:81 -I 查看响应头部</span></span><br></pre></td></tr></table></figure><h5 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.0标准</span><br><span class="line">· 301 : 永久重定向</span><br><span class="line">· 302 : 临时重定向，禁止被缓存</span><br><span class="line"></span><br><span class="line">HTTP 1.1标准</span><br><span class="line">· 303 : 临时重定向，禁止缓存，允许改变方法</span><br><span class="line">· 307 : 临时重定向，禁止缓存，不允许改变方法</span><br><span class="line">· 308 : 永久重定向，不允许改变方法</span><br></pre></td></tr></table></figure><p>永久重定向和临时重定向</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· 永久重定向  假如访问a.com时永久重定向到了b.com，浏览器在收到响应后，显示b.com的内容</span><br><span class="line">  下一次访问a.com时浏览器会直接跳转到 b.com，不会再请求a.com（本地cache）</span><br><span class="line"></span><br><span class="line">· 临时重定向  假如访问a.com时临时重定向到了b.com，浏览器在收到响应后，显示的是b.com的内容；</span><br><span class="line">  下一次当你请求a.com时浏览器还会先请求a.com，然后再重定向到b.com</span><br></pre></td></tr></table></figure><ul><li><strong>rewrite指令</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">rewrite</span> regex replacement [flag];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：server, location, if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rewrite指令按照他们在配置文件中出现的顺序依次执行</span></span><br><span class="line"><span class="comment">#可以使用flag终止对指令进一步处理</span></span><br><span class="line"><span class="comment">#如果替换字符串以http://、https://、$scheme开头，那么会停止处理，并将重定向返回给客户端</span></span><br></pre></td></tr></table></figure><p>flag参数说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· last 本条规则匹配完之后，继续匹配location</span><br><span class="line">· break 本条规则匹配完之后，直接去对应replacement替换字符串位置查找文件，不再继续匹配location</span><br><span class="line">· redirect 如果replacement不是以http://、https://、$scheme开头，返回302临时重定向 </span><br><span class="line">· permanent 返回301永久重定向</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">82</span>;</span><br><span class="line"><span class="attribute">root</span> html/test;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">index</span> test.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /images &#123;</span><br><span class="line"><span class="attribute">rewrite</span> /images/(.*) /pics/<span class="variable">$1</span>; <span class="comment">#$1代表正则第一个匹配的数据</span></span><br><span class="line"><span class="comment">#rewrite /images/(.*) /pics/$1 last;</span></span><br><span class="line"><span class="comment">#rewrite /images/(.*) /pics/$1 break;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /pics &#123;</span><br><span class="line"><span class="attribute">rewrite</span> /pics/(.*) /photos/<span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /photos &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>return和rewrite执行顺序</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#return和rewrite按顺序执行</span></span><br><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="section">location</span> /images &#123;</span><br><span class="line"><span class="attribute">rewrite</span> /images/(.*) /pics/<span class="variable">$1</span>; <span class="comment">#rewrite没有flag标识</span></span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;return 200 in /images&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /pics &#123;</span><br><span class="line">  <span class="attribute">index</span> index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问127.0.0.1:82/images/index.html</span></span><br><span class="line"><span class="comment">#执行过程：先匹配到rewrite，由于没有flag，所以顺序执行return，结果&quot;return 200 in /images&quot;；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2</span></span><br><span class="line"><span class="section">location</span> /images &#123;</span><br><span class="line"><span class="attribute">rewrite</span> /images/(.*) /pics/<span class="variable">$1</span> <span class="literal">last</span>|<span class="literal">break</span>; <span class="comment">#rewrite的flag为last</span></span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;return 200 in /images&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /pics &#123;</span><br><span class="line">  <span class="attribute">index</span> index.html; <span class="comment">#index.html内容为pics test server</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问127.0.0.1:82/images/index.html</span></span><br><span class="line"><span class="comment">#flag为last 执行过程：先匹配到rewrite，由于flag为last，所以继续匹配location到/pics，结果为pics test server；</span></span><br><span class="line"><span class="comment">#flag为break 执行过程：先匹配到rewrite，由于flag为break，不会继续匹配location，直接查找/pics/index.html文件，结果为pics test server；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3</span></span><br><span class="line"><span class="section">location</span> /images &#123;</span><br><span class="line"><span class="attribute">rewrite</span> /images/(.*) /pics/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;return 200 in /images&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /pics &#123;</span><br><span class="line"><span class="attribute">rewrite</span> /pics/(.*) /photos/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">  <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;return 200 in /pics&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /photos &#123;</span><br><span class="line">  <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;return 200 in /photos&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问127.0.0.1:82/images/index.html</span></span><br><span class="line"><span class="comment">#flag都为last，结果&quot;return 200 in /photos&quot;； </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例4</span></span><br><span class="line"><span class="section">location</span> /photos &#123;</span><br><span class="line">  <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;return 200 in /photos&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问127.0.0.1:82/photos/index.html</span></span><br><span class="line"><span class="comment">#结果&quot;return 200 in /photos&quot;；原因：如果有return的话，返回的时候就会优先执行return，而不是去返回index.html文件内容</span></span><br></pre></td></tr></table></figure><ul><li><strong>if指令</strong></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">if</span> (condition) &#123; ... &#125;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：server, location</span></span><br></pre></td></tr></table></figure><p>condition</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>$variable</td><td>仅为变量时，值为空或以0开头字符串都会被当做false处理</td></tr><tr><td>&#x3D;或!&#x3D;</td><td>相等或不等</td></tr><tr><td>~</td><td>与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写</td></tr><tr><td>~*</td><td>与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写</td></tr><tr><td>!~</td><td>与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写</td></tr><tr><td>!~*</td><td>与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写</td></tr><tr><td>-f或!-f</td><td>检查文件存在或不存在</td></tr><tr><td>-d或!-d</td><td>检查目录存在或不存在</td></tr><tr><td>-e或!-e</td><td>检查文件、目录、符号链接等存在或不存在</td></tr><tr><td>-x或!-x</td><td>检查文件可执行或不可执行</td></tr></tbody></table><p>示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">83</span>;</span><br><span class="line"><span class="attribute">root</span> html/test;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">if</span> ( <span class="variable">$uri</span> = <span class="string">&quot;/images/&quot;</span> ) &#123;</span><br><span class="line"><span class="attribute">rewrite</span> (.*) /pics/ <span class="literal">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;test if failed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果 访问127.0.0.1:83/images/</span></span><br><span class="line"><span class="attribute">test</span> if failed <span class="comment">#if执行完之后，if之外的return会被执行，一般情况下不会这么写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="autoindex模块"><a href="#autoindex模块" class="headerlink" title="autoindex模块"></a>autoindex模块</h4><h5 id="基本功能-2"><a href="#基本功能-2" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li>用户请求以&#x2F;结尾时，列出目录结构</li></ul><h5 id="指令-3"><a href="#指令-3" class="headerlink" title="指令"></a>指令</h5><ul><li>autoindex</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">autoindex</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">autoindex</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="comment">#是否开启目录展示</span></span><br></pre></td></tr></table></figure><ul><li>autoindex_exact_size</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">autoindex_exact_size</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">autoindex_exact_size</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="comment">#针对HTML模式，指定是否应在目录列表中输出确切的文件大小，或者四舍五入为千字节、兆字节和千兆字节</span></span><br></pre></td></tr></table></figure><ul><li>autoindex_format</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">autoindex_format</span> html | xml | json | jsonp;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">autoindex_format</span> html;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">7</span>.<span class="number">9</span>.</span><br><span class="line"><span class="comment">#设置目录列表的格式</span></span><br><span class="line"><span class="comment">#使用JSONP格式时，回调函数的名称由回调请求参数设置。如果参数缺失或值为空，则使用JSON格式</span></span><br></pre></td></tr></table></figure><ul><li>autoindex_localtime</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">autoindex_localtime</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">autoindex_localtime</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="comment">#对于HTML格式，指定目录列表中的时间是否应以本地时区或UTC输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">84</span>;</span><br><span class="line"><span class="attribute">root</span> html/test;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /download/ &#123;</span><br><span class="line"><span class="comment">#index a.html;</span></span><br><span class="line"><span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">autoindex_exact_size</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">autoindex_format</span> html;</span><br><span class="line"><span class="attribute">autoindex_localtime</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：index指令显示指定时，如果指定文件存在，那么autoindex不会生效；index指令不存在时，如果文件中存在index.html文件，那么autoindex也不会生效，默认会展示index.html内容</span></span><br></pre></td></tr></table></figure><h4 id="Nginx中的变量"><a href="#Nginx中的变量" class="headerlink" title="Nginx中的变量"></a>Nginx中的变量</h4><img src="/load_images/nginx16.png" alt="img" style="zoom: 40%;" /><h5 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h5><ul><li>TCP连接变量</li></ul><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>remote_addr</td><td>客户端IP地址</td></tr><tr><td>remote_port</td><td>客户端端口</td></tr><tr><td>server_addr</td><td>服务端IP地址</td></tr><tr><td>server_port</td><td>服务端端口</td></tr><tr><td>server_protocol</td><td>服务端协议</td></tr><tr><td>binary_remote_addr</td><td>二进制格式的客户端IP地址</td></tr><tr><td>connection</td><td>TCP连接的序号，递增</td></tr><tr><td>connection_requests</td><td>TCP连接当前的请求数量</td></tr><tr><td>proxy_protocol_addr</td><td>若使用了proxy_protocol协议，则返回协议中的地址，否则返回空</td></tr><tr><td>proxy_protocol_port</td><td>若使用了proxy_protocol协议，则返回协议中的端口，否则返回空</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">85</span>;</span><br><span class="line">        <span class="attribute">root</span> html;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;remote_addr: <span class="variable">$remote_addr</span></span></span><br><span class="line"><span class="string">remote_port: <span class="variable">$remote_port</span></span></span><br><span class="line"><span class="string">server_addr: <span class="variable">$server_addr</span></span></span><br><span class="line"><span class="string">server_port: <span class="variable">$server_port</span></span></span><br><span class="line"><span class="string">server_protocol: <span class="variable">$server_protocol</span></span></span><br><span class="line"><span class="string">proxy_protocol_addr: <span class="variable">$proxy_protocol_addr</span></span></span><br><span class="line"><span class="string">proxy_protocol_port: <span class="variable">$proxy_protocol_port</span></span></span><br><span class="line"><span class="string">connection_requests: <span class="variable">$connection_requests</span></span></span><br><span class="line"><span class="string">connection: <span class="variable">$connection</span> &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br></pre></td></tr></table></figure><p><img src="/load_images/nginx17.png" alt="img"></p><ul><li><p>HTTP请求变量</p></li><li><p>Nginx处理HTTP请求产生的变量</p></li><li><p>Nginx返回响应变量</p></li><li><p>Nginx内部变量</p></li></ul><p><strong>HTTP请求变量</strong></p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>uri</td><td>请求的URL，不包含参数</td></tr><tr><td>request_uri</td><td>请求的URL，包含参数</td></tr><tr><td>scheme</td><td>协议名，http或https</td></tr><tr><td>request_method</td><td>请求方法</td></tr><tr><td>request_length</td><td>全部请求的长度，包括请求行、请求头、请求体</td></tr><tr><td>args</td><td>全部参数字符串</td></tr><tr><td>arg_参数名</td><td>特定参数值</td></tr><tr><td>is_args</td><td>URL中有参数，则返回?，否则返回空</td></tr><tr><td>query_string</td><td>与args相同</td></tr><tr><td>remote_user</td><td>由HTTP Basic Authentication协议传入的用户名</td></tr><tr><td><strong>特殊变量（这些变量Nginx可能会做一些处理）</strong></td><td></td></tr><tr><td>host</td><td>优先级顺序：请求行中的host，请求头中的Host ，请求匹配到的server_name</td></tr><tr><td>http_user_agent</td><td>用户浏览器</td></tr><tr><td>http_referer</td><td>从哪些链接过来的请求 例如从百度搜索到的链接</td></tr><tr><td>http_via</td><td>经过一层代理服务器，添加对应代理服务器的信息</td></tr><tr><td>http_x_forwarded_for</td><td>获取用户真实IP</td></tr><tr><td>http_cookie</td><td>用户cookie</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">86</span>;</span><br><span class="line">        <span class="attribute">root</span> html/test;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /test &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;uri: <span class="variable">$uri</span></span></span><br><span class="line"><span class="string">request_uri: <span class="variable">$request_uri</span></span></span><br><span class="line"><span class="string">scheme: <span class="variable">$scheme</span></span></span><br><span class="line"><span class="string">request_method: <span class="variable">$request_method</span></span></span><br><span class="line"><span class="string">request_length: <span class="variable">$request_length</span></span></span><br><span class="line"><span class="string">is_args: <span class="variable">$is_args</span></span></span><br><span class="line"><span class="string">args: <span class="variable">$args</span></span></span><br><span class="line"><span class="string">query_string: <span class="variable">$query_string</span></span></span><br><span class="line"><span class="string">remote_user: <span class="variable">$remote_user</span> &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#curl &#x27;127.0.0.1:86/test?a=123&amp;b=234&#x27;</span></span><br><span class="line">uri: /<span class="attribute">test</span></span><br><span class="line">request_uri: /test?a=<span class="number">123</span>&amp;b=<span class="number">234</span></span><br><span class="line">scheme: http</span><br><span class="line">request_method: GET</span><br><span class="line">request_length: <span class="number">92</span></span><br><span class="line">is_args: ?</span><br><span class="line">args: a=<span class="number">123</span>&amp;b=<span class="number">234</span></span><br><span class="line">query_string: a=<span class="number">123</span>&amp;b=<span class="number">234</span></span><br><span class="line">remote_user:</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2</span></span><br><span class="line">server &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">87</span>;</span><br><span class="line">        <span class="attribute">root</span> html/test;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /test &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;host: <span class="variable">$host</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">curl</span> <span class="number">127.0.0.1:87</span>/test</span><br><span class="line"><span class="comment">#结果：host: 127.0.0.1</span></span><br><span class="line"></span><br><span class="line">curl <span class="number">127.0.0.1:87</span>/test -H <span class="string">&quot;Host: test.nginx.com&quot;</span> <span class="comment">#-H 添加头信息</span></span><br><span class="line"><span class="comment">#结果：host: test.nginx.com</span></span><br></pre></td></tr></table></figure><p><strong>处理HTTP请求相关变量</strong></p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>request_time</td><td>处理请求已耗费的时间</td></tr><tr><td>request_completion</td><td>请求处理完成返回OK，否则返回空</td></tr><tr><td>server_name</td><td>匹配请求的server_name值</td></tr><tr><td>https</td><td>若开启https，则返回on，否则返回空</td></tr><tr><td>request_filename</td><td>磁盘文件系统待访问文件的完整路径</td></tr><tr><td>document_root</td><td>由URI和root&#x2F;alias规则生成的文件夹路径</td></tr><tr><td>realpath_root</td><td>将document_root中的软链接换成真实路径</td></tr><tr><td>limit_rate</td><td>返回响应时的速度上限值</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">88</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line"><span class="attribute">root</span> html/test;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">50</span>;</span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;request_time: <span class="variable">$request_time</span></span></span><br><span class="line"><span class="string">request_id: <span class="variable">$request_id</span></span></span><br><span class="line"><span class="string">server_name: <span class="variable">$server_name</span></span></span><br><span class="line"><span class="string">document_root: <span class="variable">$document_root</span></span></span><br><span class="line"><span class="string">realpath_root: <span class="variable">$realpath_root</span></span></span><br><span class="line"><span class="string">limit_rate: <span class="variable">$limit_rate</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">curl</span> <span class="number">127.0.0.1:88</span></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">request_time: <span class="number">0</span>.<span class="number">000</span></span><br><span class="line">request_id: 5108c925220dc0f7b991ce25074edfd8</span><br><span class="line">server_name: localhost</span><br><span class="line">document_root: /usr/local/Cellar/nginx/<span class="number">1</span>.<span class="number">23</span>.<span class="number">1</span>/html/test</span><br><span class="line">realpath_root: /usr/local/var/www/test</span><br><span class="line">limit_rate: <span class="number">50</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Nginx处理请求的过程&quot;&gt;&lt;a href=&quot;#Nginx处理请求的过程&quot; class=&quot;headerlink&quot; title=&quot;Nginx处理请求的过程&quot;&gt;&lt;/a&gt;Nginx处理请求的过程&lt;/h3&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://codeman.club/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://codeman.club/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-负载均衡</title>
    <link href="https://codeman.club/nginx/load_balancer/"/>
    <id>https://codeman.club/nginx/load_balancer/</id>
    <published>2022-03-12T08:20:37.000Z</published>
    <updated>2022-11-07T02:48:46.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx应用场景-负载均衡"><a href="#Nginx应用场景-负载均衡" class="headerlink" title="Nginx应用场景-负载均衡"></a>Nginx应用场景-负载均衡</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>将请求代理到多台服务器去执行，这里的多台服务器通常承担一样的功能任务</p><span id="more"></span><h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><img src="/load_images/nginx_load_balance1.png" alt="img" style="zoom: 33%;" /><h4 id="uptream模块及相关指令"><a href="#uptream模块及相关指令" class="headerlink" title="uptream模块及相关指令"></a>uptream模块及相关指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span>定义一组服务器</span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="section">upstream</span> name &#123; ... &#125;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http</span></span><br><span class="line"></span><br><span class="line">server可以监听不同的端口</span><br><span class="line">监听TCP和UNIX域套接字的server可以混合使用</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>       max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="attribute">server</span> unix:/tmp/backend3;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> backup1.example.com  backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">默认情况下，请求使用加权循环平衡方法（<span class="attribute">a</span> weighted round-robin balancing method）在服务器之间分配</span><br><span class="line">上述示例，每<span class="number">7</span>个请求将按以下方式分发：第一个server分配<span class="number">5</span>个，第二、第三个server各一个；</span><br><span class="line">如果在与服务器通信时发生错误，请求被传递到下一个服务器，依次类推，直到尝试所有正常运行的服务器</span><br><span class="line">如果无法从任何服务器获得成功响应，那么客户端将收到与最后一个backup服务器通信的结果</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server语法</span></span><br><span class="line"><span class="attribute">server</span> address [parameters];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"></span><br><span class="line">address可以是IP、域名，也可以带上端口(默认80端口)，也可以是一个UNIX套接字路径</span><br><span class="line">解析为多个IP地址的域名一次定义多个服务器</span><br></pre></td></tr></table></figure><table><thead><tr><th>parameters可选值</th><th>含义</th></tr></thead><tbody><tr><td>weight&#x3D;number</td><td>权重值，默认为1</td></tr><tr><td>max_conns&#x3D;number</td><td>上游服务器的最大并发连接数</td></tr><tr><td>fail_timeout&#x3D;time</td><td>服务器不可用的判定时间</td></tr><tr><td>max_fails&#x3D;number</td><td>服务器不可用的检查次数</td></tr><tr><td>backup</td><td>备份服务器，仅当其他主服务器都不可用时，将被传递请求</td></tr><tr><td>down</td><td>标记服务器长期不可用，离线维护</td></tr><tr><td>resolve</td><td>监控服务器域名对应的IP地址变化，自动修改upstream配置，无需重启nginx；服务器组必须驻留在共享内存中</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">keepalive：限制每个worker子进程与上游服务器空闲长连接的最大数量</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">keepalive</span> connections;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#简单示例</span></span><br><span class="line"><span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#For HTTP</span></span><br><span class="line"><span class="section">upstream</span> http_backend &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /http/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://http_backend;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>; <span class="comment">#proxy_http_version需要设置为1.1</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>; <span class="comment">#proxy_set_header设置Connection为空</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#说明，如果不设置proxy_http_version为1.1，那么proxy_set_header需要设置Connection为Keep-Alive；不建议这么做</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#For FastCGI</span></span><br><span class="line"><span class="section">upstream</span> fastcgi_backend &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive</span> <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /fastcgi/ &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span> fastcgi_backend;</span><br><span class="line">        <span class="attribute">fastcgi_keep_conn</span> <span class="literal">on</span>; <span class="comment">#需要设置fastcgi_keep_conn为on</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#关于负载均衡注意点</span></span><br><span class="line">当使用默认循环方法以外的负载均衡方法时，需要在keepalive指令之前启用它们。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">keepalive_requests：设置一个keepalive连接可以处理的最大请求数。在发出最大请求数后，连接将关闭。</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">keepalive_requests</span> number;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">keepalive_requests</span> <span class="number">1000</span>; <span class="comment">#在1.19.10版本之前，默认值为 100</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">15</span>.<span class="number">3</span>.</span><br><span class="line"></span><br><span class="line">Closing connections periodically is necessary to free per-connection memory allocations. </span><br><span class="line">Therefore, using too high maximum number of requests could result in excessive memory usage and not recommended.</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keepalive_time：限制通过一个保活连接处理请求的最长时间。到了这个时间后，在后续的请求处理之后关闭连接</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">keepalive_time</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">keepalive_time</span> <span class="number">1h</span>;</span><br><span class="line"><span class="comment">#上下文upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">19</span>.<span class="number">10</span>.</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout：空闲连接的最长保持时间</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">keepalive_timeout</span> timeout;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">60s</span>;</span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">15</span>.<span class="number">3</span>.</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue：如果在处理请求时无法立即选择上游服务器，则该请求将被放入队列中</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">queue</span> number [timeout=time];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">5</span>.<span class="number">12</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">number指定在队列可以同时存在的最大请求数</span><br><span class="line">如果队列已满，或者在 timeout 参数指定的时间段内无法选择传递请求的服务器，则会向客户端返回 <span class="number">502</span> (Bad Gateway) 错误。</span><br></pre></td></tr></table></figure><h4 id="简单负载均衡示例"><a href="#简单负载均衡示例" class="headerlink" title="简单负载均衡示例"></a>简单负载均衡示例</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器，通过端口实现多台server</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8002</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8002\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8003</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8003\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8004</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8004\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#负载均衡服务器</span></span><br><span class="line"><span class="section">upstream</span> load_balancer &#123;</span><br><span class="line">        <span class="attribute">server</span> ip:<span class="number">8002</span>;</span><br><span class="line">        <span class="attribute">server</span> ip:<span class="number">8003</span>;</span><br><span class="line">        <span class="attribute">server</span> ip:<span class="number">8004</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">92</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /balance/ &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://load_balancer;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">hash</span> key [consistent];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">7</span>.<span class="number">2</span>.</span><br><span class="line"></span><br><span class="line">基于key的哈希值来做客户端和服务端的映射。</span><br><span class="line">key可以包含文本、变量及其组合</span><br><span class="line">注意，从服务器组中添加或删除服务器可能会导致将大部分密钥重新映射到不同的服务器</span><br><span class="line"></span><br><span class="line">如果指定了consistent一致参数，则将使用ketama一致哈希方法。</span><br><span class="line">该方法确保在将服务器添加到组或从组中删除时，只有少数密钥将重新映射到不同的服务器。</span><br><span class="line">这有助于为缓存服务器实现更高的缓存命中率</span><br></pre></td></tr></table></figure><h5 id="基于uri的哈希值做简单负载均衡"><a href="#基于uri的哈希值做简单负载均衡" class="headerlink" title="基于uri的哈希值做简单负载均衡"></a>基于uri的哈希值做简单负载均衡</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8005</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8005\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8006</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8006\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#负载均衡服务器</span></span><br><span class="line"><span class="section">upstream</span> hash &#123;</span><br><span class="line">        <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">        <span class="attribute">server</span> ip:<span class="number">8005</span>;</span><br><span class="line">        <span class="attribute">server</span> ip:<span class="number">8006</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://hash;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:93/a</span><br><span class="line">Return Result For Server 8005</span><br><span class="line"></span><br><span class="line">curl 127.0.0.1:93/b</span><br><span class="line">Return Result For Server 8006</span><br></pre></td></tr></table></figure><h4 id="ip-hash算法"><a href="#ip-hash算法" class="headerlink" title="ip_hash算法"></a>ip_hash算法</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：</span></span><br><span class="line">ip_hash;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"></span><br><span class="line">指定服务器组应使用基于客户端IP地址在服务器之间分配请求的负载均衡方法</span><br><span class="line">客户端IPv4地址的前三个八位字节或整个IPv6地址用作散列密钥</span><br><span class="line">该方法确保来自同一客户端的请求将始终传递到同一服务器，除非该服务器不可用。在后一种情况下，客户端请求将被传递到另一台服务器</span><br><span class="line"></span><br><span class="line">如果需要临时删除其中一台服务器，则应使用down参数对其进行标记，以保留客户端IP地址的当前哈希</span><br><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend3.example.com down;</span><br><span class="line">    <span class="attribute">server</span> backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h4><p>考虑上游服务器的负载情况，挑选一台当前已建立连接数量最少的服务器去分配请求</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：</span></span><br><span class="line">least_conn;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in versions <span class="number">1</span>.<span class="number">3</span>.<span class="number">1</span> and <span class="number">1</span>.<span class="number">2</span>.<span class="number">2</span>.</span><br><span class="line"></span><br><span class="line">指定组应使用将请求传递到具有最少活动连接数的服务器的负载均衡方法，同时考虑服务器的权重</span><br><span class="line">如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。</span><br><span class="line"></span><br><span class="line">不同的worker process不知道其他子进程的连接情况，此时需要共享内存去解决这个问题</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">zone</span> name [size];</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：upstream</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">9</span>.<span class="number">0</span>.</span><br><span class="line"></span><br><span class="line">定义共享内存区域的名称和大小，以保持worker进程之间共享的组配置和运行时状态。</span><br><span class="line">几个组可以共享同一个区域。在这种情况下，只指定一次大小就足够了。</span><br><span class="line"></span><br><span class="line">upstream demo &#123;</span><br><span class="line">    <span class="attribute">zone</span> test <span class="number">10M</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h4><p>Nginx针对上游服务返回异常时的容错机制</p><h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | <span class="literal">off</span> ...;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">指定在哪些情况下应将请求传递给下一个服务器</span><br></pre></td></tr></table></figure><table><thead><tr><th>可选参数</th><th>含义</th></tr></thead><tbody><tr><td>error</td><td>与上游服务器建立连接、向其传递请求或读取响应头时发生错误</td></tr><tr><td>timeout</td><td>与上游服务器建立连接、向其传递请求或读取响应头时发生超时</td></tr><tr><td>invalid_header</td><td>上游服务器返回空响应或无效响应</td></tr><tr><td>http_500</td><td>服务器返回了带有代码 500 的响应</td></tr><tr><td>http_502</td><td>服务器返回了带有代码 502 的响应</td></tr><tr><td>http_503</td><td>服务器返回了带有代码 503 的响应</td></tr><tr><td>http_504</td><td>服务器返回了带有代码 504的响应</td></tr><tr><td>http_403</td><td>服务器返回了带有代码 403 的响应</td></tr><tr><td>http_404</td><td>服务器返回了带有代码 404 的响应</td></tr><tr><td>http_429</td><td>服务器返回了带有代码 429 的响应</td></tr><tr><td>non_idempotent</td><td>通常，如果请求已发送到上游服务器，则使用非幂等方法（POST、LOCK、PATCH）的请求不会传递到下一个服务器；<br />显式启用此选项允许重试此类请求</td></tr><tr><td>off</td><td>禁止将请求传递到下一个服务器</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">应该记住，只有在尚未向客户端发送任何内容的情况下，才有可能将请求传递给下一个服务器。也就是说，如果在传输响应的过程中发生错误或超时，则无法解决此问题</span><br><span class="line"></span><br><span class="line">该指令还定义了与服务器通信不成功的尝试：upstream模块的max_fails设置的不成功尝试次数</span><br><span class="line">error、timeout和invalid_header总是被当做不成功尝试，即使它们没有在指令中指定</span><br><span class="line">http_500、http_502、http_503、http_504 和 http_429 的情况只有在指令中指定时才被认为是不成功的尝试</span><br><span class="line">http_403 和 http_404 的情况永远不会被认为是不成功的尝试。</span><br><span class="line"></span><br><span class="line">将请求传递到下一个服务器可能会受到尝试次数max_fails和时间fail_timeout的限制</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_next_upstream_timeout</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_next_upstream_timeout</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">7</span>.<span class="number">5</span>.</span><br><span class="line"></span><br><span class="line">限制可以将请求传递到下一个服务器的时间。 <span class="number">0</span>值关闭此限制。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_next_upstream_tries</span> number;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_next_upstream_tries</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"><span class="attribute">This</span> directive appeared in version <span class="number">1</span>.<span class="number">7</span>.<span class="number">5</span>.</span><br><span class="line"></span><br><span class="line">限制将请求传递到下一个服务器的可能尝试次数。 <span class="number">0</span>值关闭此限制。</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_read_timeout</span> time;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">60s</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">定义从代理服务器读取响应的超时时间</span><br><span class="line">超时仅在两个连续的读取操作之间设置，不是为了整个响应的传输</span><br><span class="line">如果代理服务器在这段时间内没有传输任何内容，则关闭连接</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#默认值</span></span><br><span class="line"><span class="attribute">proxy_intercept_errors</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment">#上下文：http, server, location</span></span><br><span class="line"></span><br><span class="line">上游服务器响应码大于300时，是直接将上游响应返回给客户端（off）还是被拦截并重定向到nginx以使用error_page指令进行处理（on）</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="attribute">error_page</span> code ... [=[response]] uri;</span><br><span class="line"><span class="comment">#默认值：无</span></span><br><span class="line"><span class="comment">#上下文：http, server, location, if in location</span></span><br><span class="line">定义将针对指定错误显示的 URI。 <span class="attribute">uri</span> 值可以包含变量</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">error_page <span class="number">404</span>             /<span class="number">404</span>.html;</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">这会导致内部重定向到指定的 uri，客户端请求方法更改为“GET”（对于“GET”和“HEAD”以外的所有方法）</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">此外，可以使用“=response”语法将响应码更改为另一个码，例如：</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> =<span class="number">200</span> /empty.gif;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">如果错误响应由代理服务器或FastCGI/uwsgi/SCGI/<span class="attribute">gRPC</span> 服务器处理，</span><br><span class="line">并且服务器可能返回不同的响应代码（例如，<span class="number">200</span>、<span class="number">302</span>、<span class="number">401</span> 或 <span class="number">404</span>），那么这些返回的状态码也可以由本指令处理：</span><br><span class="line">error_page <span class="number">404</span> = /<span class="number">404</span>.php;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">如果在内部重定向过程中不需要更改URI和方法,可以将错误处理传递到命名路径</span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> = <span class="variable">@fallback</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> <span class="variable">@fallback</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">&#125;</span><br><span class="line">如果处理uri产生了错误，那么nginx将最后一次出错的HTTP响应状态码返回给客户端。也就是说备用服务器还是不行的话会直接展示这台服务器的响应码。</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">也可以使用URL重定向进行错误处理：</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">403</span>      http://example.com/forbidden.html; <span class="comment">#使用URL重定向，默认情况下会向客户端返回响应码302</span></span><br><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> =<span class="number">301</span> http://example.com/notfound.html; <span class="comment">#使用URL重定向，只能更改为重定向状态代码之一（301、302、303、307 和 308）</span></span><br><span class="line">总结：使用URL重定向，默认情况下会向客户端返回响应码302。而且它只能更改为重定向状态代码之一（301、302、303、307 和 308）。</span><br><span class="line"></span><br><span class="line">当且仅当当前级别上没有定义 <span class="attribute">error_page</span> 指令时，这些指令才从先前的配置级别继承。</span><br></pre></td></tr></table></figure><h5 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h5><p>一、模拟一台服务器挂掉（通过注释掉8008server配置模拟）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8007\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#server &#123;</span></span><br><span class="line"><span class="comment">#        listen 8008;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#        location / &#123;</span></span><br><span class="line"><span class="comment">#                return 200 &#x27;Return Result For Server 8008\n&#x27;;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#负载均衡服务器配置</span></span><br><span class="line"><span class="section">upstream</span> test_tolerant_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8007</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8008</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">94</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /test/ &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://test_tolerant_server;</span><br><span class="line">                <span class="attribute">proxy_next_upstream</span> <span class="literal">off</span>; <span class="comment">#禁止将请求传递到下一个服务器</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">curl</span> <span class="number">127.0.0.1:94</span>/test/ -V <span class="comment">#查看详细信息</span></span><br></pre></td></tr></table></figure><p><img src="/load_images/nginx_load_balance2.png" alt="img"></p><p>可以看到，当请求被分配到8008这个服务器的时候，直接返回502，而不会尝试将请求发送给其他服务器（8007）。</p><p>二、模拟一台服务器响应超时</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8007\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8008</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1</span>; <span class="comment">#设置响应速率，为了模拟响应超时场景，这里把速率设为1字节</span></span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8008\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#负载均衡服务器配置</span></span><br><span class="line"><span class="section">upstream</span> test_tolerant_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8007</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8008</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">94</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /test/ &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://test_tolerant_server;</span><br><span class="line">                <span class="attribute">proxy_next_upstream</span> timeout;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">5</span>; <span class="comment">#从上游服务器读取响应的超时时间</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:94/test/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到当请求被分到8008server时，响应有明显的延迟，5秒后请求被转发到8007server</span></span><br></pre></td></tr></table></figure><p>三、模拟响应码</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8007\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8008</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">503</span> <span class="string">&#x27;Return Result For Server 8008\n&#x27;</span>; <span class="comment">#设置响应码为503</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#负载均衡服务器配置</span></span><br><span class="line"><span class="section">upstream</span> test_tolerant_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8007</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8008</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">94</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /test/ &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://test_tolerant_server;</span><br><span class="line">                <span class="attribute">proxy_next_upstream</span> http_503; <span class="comment">#设置在http响应码为503时把请求转发到其他服务器</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:94/test/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只会把请求打到8007server上</span></span><br></pre></td></tr></table></figure><p>四、模拟响应码-通过error_page处理</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;Return Result For Server 8007\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8008</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">503</span> <span class="string">&#x27;Return Result For Server 8008\n&#x27;</span>; <span class="comment">#设置响应码为503</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#负载均衡服务器配置</span></span><br><span class="line"><span class="section">upstream</span> test_tolerant_server &#123;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8007</span>;</span><br><span class="line">        <span class="attribute">server</span> ip|domain:<span class="number">8008</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">94</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /<span class="number">503</span>.html &#123; <span class="comment">#注意创建503.html文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /test/ &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://test_tolerant_server;</span><br><span class="line">                <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line">                <span class="attribute">error_page</span> <span class="number">503</span> /<span class="number">503</span>.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:94/test/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到，当请求被分配到8008服务器的时候，会被重定向到503error_page</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Nginx应用场景-负载均衡&quot;&gt;&lt;a href=&quot;#Nginx应用场景-负载均衡&quot; class=&quot;headerlink&quot; title=&quot;Nginx应用场景-负载均衡&quot;&gt;&lt;/a&gt;Nginx应用场景-负载均衡&lt;/h3&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;将请求代理到多台服务器去执行，这里的多台服务器通常承担一样的功能任务&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://codeman.club/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://codeman.club/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>mailhog邮件服务</title>
    <link href="https://codeman.club/mail/mailhog/"/>
    <id>https://codeman.club/mail/mailhog/</id>
    <published>2021-09-28T06:26:18.000Z</published>
    <updated>2022-11-07T02:47:20.840Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/mailhog/MailHog">MailHog</a></p><span id="more"></span><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew search mailhog</span><br><span class="line">brew install mailhog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行</span></span><br><span class="line">mailhog</span><br></pre></td></tr></table></figure><p>the SMTP server starts on port 1025<br>the HTTP server starts on port 8025</p><h5 id="laravel-env文件配置"><a href="#laravel-env文件配置" class="headerlink" title="laravel .env文件配置"></a>laravel .env文件配置</h5><p><img src="/load_images/mailhog.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/mailhog/MailHog&quot;&gt;MailHog&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Mail" scheme="https://codeman.club/categories/Mail/"/>
    
    
    <category term="Mail" scheme="https://codeman.club/tags/Mail/"/>
    
  </entry>
  
  <entry>
    <title>PHP-编译安装扩展</title>
    <link href="https://codeman.club/php/php_extension/"/>
    <id>https://codeman.club/php/php_extension/</id>
    <published>2021-09-24T15:24:21.000Z</published>
    <updated>2022-11-07T02:50:08.506Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装示例"><a href="#安装示例" class="headerlink" title="安装示例"></a>安装示例</h4><h5 id="一、执行phpize"><a href="#一、执行phpize" class="headerlink" title="一、执行phpize"></a>一、执行phpize</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入php7.4的源码包中gd扩展的目录</span></span><br><span class="line">cd /usr/local/src/php-7.4.28/ext/gd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行phpize</span></span><br><span class="line">/usr/local/php/php74/bin/phpize</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="二、此编译成功后会生成configure可执行文件："><a href="#二、此编译成功后会生成configure可执行文件：" class="headerlink" title="二、此编译成功后会生成configure可执行文件："></a>二、此编译成功后会生成configure可执行文件：</h5><p><img src="/load_images/php_extension1.png" alt="img"></p><p><img src="/load_images/php_extension2.png" alt="img"></p><h5 id="三、然后执行："><a href="#三、然后执行：" class="headerlink" title="三、然后执行："></a>三、然后执行：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-php-config=/usr/local/php/php74/bin/php-config</span><br></pre></td></tr></table></figure><p><img src="/load_images/php_extension3.png" alt="imag"></p><h5 id="四、编译成功后会生成对应的Makefile："><a href="#四、编译成功后会生成对应的Makefile：" class="headerlink" title="四、编译成功后会生成对应的Makefile："></a>四、编译成功后会生成对应的Makefile：</h5><p><img src="/load_images/php_extension4.png" alt="img"></p><h5 id="五、make-amp-amp-make-install"><a href="#五、make-amp-amp-make-install" class="headerlink" title="五、make &amp;&amp; make install"></a>五、make &amp;&amp; make install</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="六、修改php-ini"><a href="#六、修改php-ini" class="headerlink" title="六、修改php.ini"></a>六、修改php.ini</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;extension=\&quot;gd.so\&quot;&quot; &gt;&gt; /usr/local/php/php74/etc/php.ini</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">之后重启PHP</span></span><br><span class="line"></span><br><span class="line">php74 -m</span><br></pre></td></tr></table></figure><p>需要注意的是，如果在安装php的时候，指定了–enable-gd，那么再使用编译安装gd，就会出现以下报错：</p><p><img src="/load_images/php_extension5.png" alt="img"></p><p>原因是：再php4.3版本之后，编译过程中使用–enable-gd后，表示gd已经编译过了，不能在使用以上方法进行重复编译</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;安装示例&quot;&gt;&lt;a href=&quot;#安装示例&quot; class=&quot;headerlink&quot; title=&quot;安装示例&quot;&gt;&lt;/a&gt;安装示例&lt;/h4&gt;&lt;h5 id=&quot;一、执行phpize&quot;&gt;&lt;a href=&quot;#一、执行phpize&quot; class=&quot;headerlink&quot; title=&quot;一、执行phpize&quot;&gt;&lt;/a&gt;一、执行phpize&lt;/h5&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;进入php7.4的源码包中gd扩展的目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd /usr/local/src/php-7.4.28/ext/gd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;执行phpize&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/usr/local/php/php74/bin/phpize&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://codeman.club/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://codeman.club/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>多版本PECL安装及使用</title>
    <link href="https://codeman.club/php/pecl_multi_version/"/>
    <id>https://codeman.club/php/pecl_multi_version/</id>
    <published>2021-09-24T06:52:52.000Z</published>
    <updated>2022-11-07T02:49:57.614Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pear.php.net/manual/en/installation.getting.php">官方文档</a></p><h5 id="一、下载安装"><a href="#一、下载安装" class="headerlink" title="一、下载安装"></a>一、下载安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://pear.php.net/go-pear.phar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果存在多版本PHP，需要指定PHP，多版本PECL安装方式相同</span></span><br><span class="line">sudo /usr/local/php/php74/bin/php go-pear.phar </span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="二、输入对应数字指定目录"><a href="#二、输入对应数字指定目录" class="headerlink" title="二、输入对应数字指定目录:"></a>二、输入对应数字指定目录:</h5><p><img src="/load_images/pecl_install.png" alt="img"></p><h5 id="三、配置环境变量"><a href="#三、配置环境变量" class="headerlink" title="三、配置环境变量"></a>三、配置环境变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias pecl74=&quot;/usr/local/php/php74/bin/pecl&quot;</span><br><span class="line">alias pear74=&quot;/usr/local/php/php74/bin/pear&quot;</span><br></pre></td></tr></table></figure><h5 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用pecl安装Redis扩展</span></span><br><span class="line">pecl74 search redis</span><br><span class="line">pecl74 install redis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改php.ini，添加redis.so</span></span><br><span class="line">extension=redis.so</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启PHP</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">php74 -m</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pear.php.net/manual/en/installation.getting.php&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;一、下载安装&quot;&gt;&lt;a href=&quot;#一、下载安装&quot; class=&quot;headerlink&quot; title=&quot;一、下载安装&quot;&gt;&lt;/a&gt;一、下载安装&lt;/h5&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -O https://pear.php.net/go-pear.phar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;如果存在多版本PHP，需要指定PHP，多版本PECL安装方式相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo /usr/local/php/php74/bin/php go-pear.phar &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://codeman.club/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://codeman.club/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Mac编译多版本PHP</title>
    <link href="https://codeman.club/php/php_multi_version/"/>
    <id>https://codeman.club/php/php_multi_version/</id>
    <published>2021-09-24T05:56:28.000Z</published>
    <updated>2022-11-07T02:50:15.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PHP8-0编译安装"><a href="#PHP8-0编译安装" class="headerlink" title="PHP8.0编译安装"></a>PHP8.0编译安装</h4><h5 id="一、下载源码、创建目录"><a href="#一、下载源码、创建目录" class="headerlink" title="一、下载源码、创建目录"></a>一、下载源码、创建目录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/php/php80</span><br><span class="line"></span><br><span class="line">cd /usr/local/src</span><br><span class="line">wget https://www.php.net/distributions/php-8.0.16.tar.gz</span><br><span class="line">tar zxvf php-8.0.16.tar.gz</span><br><span class="line">cd php-8.0.16</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成 configure 文件(可不用)</span></span><br><span class="line">./buildconf --force</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置构建流程</span></span><br><span class="line">sudo ./configure --prefix=/usr/local/php/php80/ \</span><br><span class="line">--with-config-file-path=/usr/local/php/php80/etc \</span><br><span class="line">--with-config-file-scan-dir=/usr/local/php/php80/etc/conf.d \</span><br><span class="line">--with-mhash \</span><br><span class="line">--with-mysqli=shared,mysqlnd \</span><br><span class="line">--with-pdo-mysql=shared,mysqlnd \</span><br><span class="line">--enable-gd \</span><br><span class="line">--with-openssl=/usr/local/Cellar/openssl@1.1/1.1.1m \</span><br><span class="line">--with-iconv=/usr/local/opt/libiconv/ \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-zip \</span><br><span class="line">--disable-debug \</span><br><span class="line">--disable-rpath \</span><br><span class="line">--enable-xml \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--enable-soap \</span><br><span class="line">--without-pear \</span><br><span class="line">--with-gettext=/usr/local/opt/gettext \</span><br><span class="line">--enable-session \</span><br><span class="line">--with-curl \</span><br><span class="line">--with-jpeg \</span><br><span class="line">--with-freetype \</span><br><span class="line">--enable-gd-jis-conv \</span><br><span class="line">--enable-opcache \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--without-gdbm \</span><br><span class="line">--enable-fast-install \</span><br><span class="line">--disable-fileinfo</span><br></pre></td></tr></table></figure><h5 id="三、可能会出现的问题"><a href="#三、可能会出现的问题" class="headerlink" title="三、可能会出现的问题"></a>三、可能会出现的问题</h5><h6 id="1-openssl"><a href="#1-openssl" class="headerlink" title="1.openssl"></a>1.openssl</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">没有找到openssl导致</span></span><br><span class="line">configure: error: Package requirements (openssl &gt;= 1.0.1) were not met:</span><br><span class="line"></span><br><span class="line">No package &#x27;openssl&#x27; found</span><br><span class="line"></span><br><span class="line">Consider adjusting the PKG_CONFIG_PATH environment variable if you</span><br><span class="line">installed software in a non-standard prefix.</span><br><span class="line"></span><br><span class="line">Alternatively, you may set the environment variables OPENSSL_CFLAGS</span><br><span class="line">and OPENSSL_LIBS to avoid the need to call pkg-config.</span><br><span class="line">See the pkg-config man page for more details.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">另一种可能是编译参数中openssl路径不对，注意brew安装路径</span></span><br></pre></td></tr></table></figure><p>问题解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果是使用brew安装的openssl，可以先使用brew list查看是否安装过openssl</span></span><br><span class="line">brew list;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果安装过，可以执行：</span></span><br><span class="line">brew link openssl@1.1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这时会收到警告：</span></span><br><span class="line">Warning: Refusing to link macOS provided/shadowed software: openssl@1.1</span><br><span class="line">If you need to have openssl@1.1 first in your PATH run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/usr/local/opt/openssl@1.1/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find openssl@1.1 you may need to set:</span><br><span class="line">  export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot;</span><br><span class="line">  export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include&quot;</span><br><span class="line"></span><br><span class="line">For pkg-config to find openssl@1.1 you may need to set:</span><br><span class="line">  export PKG_CONFIG_PATH=&quot;/usr/local/opt/openssl@1.1/lib/pkgconfig&quot;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">首先添加~/.zshrc环境变量：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pkgconfig</span></span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">openssl</span></span><br><span class="line">export OPENSSL_LIBS=&quot;-L/usr/local/Cellar/openssl@1.1/1.1.1q/lib&quot;</span><br><span class="line">export OPENSSL_CFLAGS=&quot;-I/usr/local/Cellar/openssl@1.1/1.1.1q/include&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后注册到pkgconfig</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看openssl是否在pkgconfig中</span></span><br><span class="line">pkg-config --list-all | grep openssl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不在pkgconfig中，可以新建软链接</span></span><br><span class="line">ln -s /usr/local/Cellar/openssl@1.1/1.1.1q/lib/pkgconfig/openssl.pc /usr/local/lib/pkgconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果还报libcrypto.pc  libssl.pc相关错误，那么也要建立软连接</span></span><br><span class="line">ln -s /usr/local/Cellar/openssl@1.1/1.1.1q/lib/pkgconfig/libcrypto.pc /usr/local/lib/pkgconfig</span><br><span class="line">ln -s /usr/local/Cellar/openssl@1.1/1.1.1q/lib/pkgconfig/libssl.pc /usr/local/lib/pkgconfig</span><br></pre></td></tr></table></figure><h6 id="2-libjpeg"><a href="#2-libjpeg" class="headerlink" title="2.libjpeg"></a>2.libjpeg</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果报libjpeg相关错误，且通过brew安装没有效果</span></span><br><span class="line">./configure --help</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看jepe参数配置</span></span><br><span class="line">  --with-jpeg             GD: Enable JPEG support (only for bundled libgd) #仅适用于捆绑的libgd</span><br><span class="line">brew install libgd</span><br></pre></td></tr></table></figure><h6 id="3-pkg-config"><a href="#3-pkg-config" class="headerlink" title="3.pkg-config"></a>3.pkg-config</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configure: error: The pkg-config script could not be found or is too old.  Make sure it</span><br><span class="line">is in your PATH or set the PKG_CONFIG environment variable to the full</span><br><span class="line">path to pkg-config.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">问题解决</span></span><br><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure><h6 id="4-gettext"><a href="#4-gettext" class="headerlink" title="4.gettext"></a>4.gettext</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">configure: error: Cannot locate header file libintl.h</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">原因 --with-gettext编译报错，没有找到gettext可执行文件，因为configure文件中gettext的默认path是</span></span><br><span class="line">for i in $PHP_GETTEXT /usr/local /usr ;do</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">问题解决</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">找到对应可执行程序路径</span></span><br><span class="line">which gettext</span><br><span class="line">/usr/local/opt/gettext/bin/gettext</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果<span class="built_in">which</span>没有结果，那么执行安装</span></span><br><span class="line">brew install gettext</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改--with-gettext</span></span><br><span class="line">--with-gettext=/usr/local/opt/gettext</span><br></pre></td></tr></table></figure><h6 id="5-iconv"><a href="#5-iconv" class="headerlink" title="5.iconv"></a>5.iconv</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">configure: error: Please specify the install prefix of iconv with --with-iconv=&lt;DIR&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">原因：–with-iconv编译报错，没有找到iconv的可执行文件,或者系统中没有libiconv</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">问题解决</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">找到对应可执行程序路径</span></span><br><span class="line">which iconv</span><br><span class="line">/usr/local/opt/libiconv/bin/iconv</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果<span class="built_in">which</span>找不到</span></span><br><span class="line">brew install libiconv</span><br><span class="line">whcih iconv</span><br><span class="line">/usr/local/opr/libconv/bin/iconv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改--with-iconv</span></span><br><span class="line">--with-iconv=/usr/local/opt/libiconv/</span><br></pre></td></tr></table></figure><h6 id="6-类似问题可以使用-x2F-configure-–help-gt-gt-文件名-txt-查找对应编译参数，查看参数是否改名或者移除了，例如："><a href="#6-类似问题可以使用-x2F-configure-–help-gt-gt-文件名-txt-查找对应编译参数，查看参数是否改名或者移除了，例如：" class="headerlink" title="6.类似问题可以使用**.&#x2F;configure –help [&gt;&gt; 文件名.txt]** 查找对应编译参数，查看参数是否改名或者移除了，例如："></a>6.类似问题可以使用**.&#x2F;configure –help [&gt;&gt; 文件名.txt]** 查找对应编译参数，查看参数是否改名或者移除了，例如：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: unrecognized options: --with-xmlrpc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">原因：xmlrpc在PHP8中移到了pecl中</span></span><br></pre></td></tr></table></figure><h6 id="7-所有问题都解决后，重新编译，成功后显示："><a href="#7-所有问题都解决后，重新编译，成功后显示：" class="headerlink" title="7.所有问题都解决后，重新编译，成功后显示："></a>7.所有问题都解决后，重新编译，成功后显示：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">| License:                                                           |</span><br><span class="line">| This software is subject to the PHP License, available in this     |</span><br><span class="line">| distribution in the file LICENSE. By continuing this installation  |</span><br><span class="line">| process, you are bound by the terms of this license agreement.     |</span><br><span class="line">| If you do not agree with the terms of this license, you must abort |</span><br><span class="line">| the installation process at this point.                            |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">Thank you for using PHP.</span><br></pre></td></tr></table></figure><h5 id="四、安装（可能需要sudo权限）"><a href="#四、安装（可能需要sudo权限）" class="headerlink" title="四、安装（可能需要sudo权限）"></a>四、安装（可能需要sudo权限）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make后的结果</span></span><br><span class="line">Generating phar.php</span><br><span class="line">Generating phar.phar</span><br><span class="line">PEAR package PHP_Archive not installed: generated phar will require PHP&#x27;s phar extension be enabled.</span><br><span class="line">directorytreeiterator.inc</span><br><span class="line">clicommand.inc</span><br><span class="line">directorygraphiterator.inc</span><br><span class="line">invertedregexiterator.inc</span><br><span class="line">pharcommand.inc</span><br><span class="line">phar.inc</span><br><span class="line"></span><br><span class="line">Build complete.</span><br><span class="line">Don&#x27;t forget to run &#x27;make test&#x27;.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make install</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h5 id="五、配置文件"><a href="#五、配置文件" class="headerlink" title="五、配置文件"></a>五、配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp php.ini-development /usr/local/php/php80/etc/php.ini</span><br><span class="line">  cp /usr/local/php/php80/etc/php-fpm.conf.default /usr/local/php/php80/etc/php-fpm.conf</span><br><span class="line">cp /usr/local/php/php80/etc/php-fpm.d/www.conf.default /usr/local/php/php80/etc/php-fpm.d/www.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：如果是多版本PHP，记得修改www.conf中php-fpm监听的端口listen=127.0.0.1:9001</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改php-fpm.conf</span></span><br><span class="line">pid = run/php-fpm.pid #前面的注释去掉</span><br></pre></td></tr></table></figure><h5 id="六、使用PHP自带的webserver测试是否安装成功"><a href="#六、使用PHP自带的webserver测试是否安装成功" class="headerlink" title="六、使用PHP自带的webserver测试是否安装成功"></a>六、使用PHP自带的webserver测试是否安装成功</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建index.php</span></span><br><span class="line">cd PHPProjects/test</span><br><span class="line">vim index.php</span><br><span class="line">&lt;?php</span><br><span class="line">    phpinfo();</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行</span>   </span><br><span class="line">/usr/local/php/php80/bin/php -c /usr/local/php/php80/etc/php.ini -S localhost:9002</span><br><span class="line">[Mon May  4 16:46:01 2020] PHP 7.4.5 Development Server (http://localhost:9002) started</span><br></pre></td></tr></table></figure><p>打开浏览器访问：localhost:9002</p><p><img src="/load_images/php_webserver.png" alt="img"></p><h5 id="七、Mac环境变量配置"><a href="#七、Mac环境变量配置" class="headerlink" title="七、Mac环境变量配置"></a>七、Mac环境变量配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias php80=&quot;/usr/local/php/php80/bin/php&quot;</span><br><span class="line">alias phpfpm80=&quot;sudo /usr/local/php/php80/sbin/php-fpm&quot;</span><br></pre></td></tr></table></figure><h5 id="八、启动、关闭php-fpm"><a href="#八、启动、关闭php-fpm" class="headerlink" title="八、启动、关闭php-fpm"></a>八、启动、关闭php-fpm</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看</span></span><br><span class="line">ps aux | grep php-fpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭</span></span><br><span class="line">sudo kill -INT `cat /usr/local/php/php80/var/run/php-fpm.pid`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">sudo kill -USR2 `cat /usr/local/php/php80/var/run/php-fpm.pid`</span><br></pre></td></tr></table></figure><h4 id="PHP7-4编译安装"><a href="#PHP7-4编译安装" class="headerlink" title="PHP7.4编译安装"></a>PHP7.4编译安装</h4><h5 id="一、下载源码、创建目录-1"><a href="#一、下载源码、创建目录-1" class="headerlink" title="一、下载源码、创建目录"></a>一、下载源码、创建目录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/php/php74</span><br><span class="line"></span><br><span class="line">cd /usr/local/src</span><br><span class="line">wget https://www.php.net/distributions/php-7.4.28.tar.gz</span><br><span class="line">tar zxvf php-7.4.28.tar.gz</span><br><span class="line">cd php-7.4.28</span><br></pre></td></tr></table></figure><h5 id="二、编译-1"><a href="#二、编译-1" class="headerlink" title="二、编译"></a>二、编译</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --prefix=/usr/local/php/php74/ \</span><br><span class="line">--with-config-file-path=/usr/local/php/php74/etc \</span><br><span class="line">--with-config-file-scan-dir=/usr/local/php/php74/etc/conf.d \</span><br><span class="line">--with-mhash \</span><br><span class="line">--with-mysqli=shared,mysqlnd \</span><br><span class="line">--with-pdo-mysql=shared,mysqlnd \</span><br><span class="line">--enable-gd \</span><br><span class="line">--with-openssl=/usr/local/Cellar/openssl@1.1/1.1.1q \</span><br><span class="line">--with-iconv=/usr/local/opt/libiconv/ \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-zip \</span><br><span class="line">--enable-inline-optimization \</span><br><span class="line">--disable-debug \</span><br><span class="line">--disable-rpath \</span><br><span class="line">--enable-xml \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--with-xmlrpc \</span><br><span class="line">--enable-soap \</span><br><span class="line">--without-pear \</span><br><span class="line">--with-gettext=/usr/local/opt/gettext \</span><br><span class="line">--enable-session \</span><br><span class="line">--with-curl \</span><br><span class="line">--with-jpeg \</span><br><span class="line">--with-freetype \</span><br><span class="line">--enable-gd-jis-conv \</span><br><span class="line">--enable-opcache \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--without-gdbm \</span><br><span class="line">--enable-fast-install \</span><br><span class="line">--disable-fileinfo</span><br></pre></td></tr></table></figure><h5 id="三、其他同8-0安装"><a href="#三、其他同8-0安装" class="headerlink" title="三、其他同8.0安装"></a>三、其他同8.0安装</h5><h4 id="多版本composer配置"><a href="#多版本composer配置" class="headerlink" title="多版本composer配置"></a>多版本composer配置</h4><p><a href="https://getcomposer.org/download/">composer下载</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把composer.phar放入指定文件夹</span></span><br><span class="line">mkdir ~/php_plugin</span><br><span class="line">mv composer.phar ~/php_plugin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置环境变量，指定PHP版本即可</span></span><br><span class="line">alias composer7=&quot;/usr/local/php/php74/bin/php /Users/nonfishz/php_plugin/composer.phar &quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试结果</span></span><br><span class="line">composer7</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;PHP8-0编译安装&quot;&gt;&lt;a href=&quot;#PHP8-0编译安装&quot; class=&quot;headerlink&quot; title=&quot;PHP8.0编译安装&quot;&gt;&lt;/a&gt;PHP8.0编译安装&lt;/h4&gt;&lt;h5 id=&quot;一、下载源码、创建目录&quot;&gt;&lt;a href=&quot;#一、下载源码、创建目录&quot; class=&quot;headerlink&quot; title=&quot;一、下载源码、创建目录&quot;&gt;&lt;/a&gt;一、下载源码、创建目录&lt;/h5&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir /usr/local/php/php80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd /usr/local/src&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget https://www.php.net/distributions/php-8.0.16.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar zxvf php-8.0.16.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd php-8.0.16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://codeman.club/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://codeman.club/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>MySQL InnoDB MVCC机制的原理及实现</title>
    <link href="https://codeman.club/mysql/mvcc/"/>
    <id>https://codeman.club/mysql/mvcc/</id>
    <published>2021-06-10T16:11:25.000Z</published>
    <updated>2022-11-07T02:47:42.374Z</updated>
    
    <content type="html"><![CDATA[<p>MVCC（Multiversion Concurrency Control）多版本并发控制，通过一种可见性算法来实现数据库并发控制。</p><span id="more"></span><h4 id="两种读形式"><a href="#两种读形式" class="headerlink" title="两种读形式"></a>两种读形式</h4><ul><li>快照读：读取的是当前事务的课件版本，不用加锁（简单的select就是快照读）</li><li>当前读：读取的是当前版本，例如更新、插入、删除操作以及特殊的读操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update table set ...</span><br><span class="line">insert into table ...</span><br><span class="line">delete from table where ...</span><br><span class="line"></span><br><span class="line">/*特殊的读操作*/</span><br><span class="line">select * from table where ... lock in share mode;</span><br><span class="line">select * from table where ... for update;</span><br></pre></td></tr></table></figure><h4 id="uodo-log-回滚日志"><a href="#uodo-log-回滚日志" class="headerlink" title="uodo log 回滚日志"></a>uodo log 回滚日志</h4><p>undo log是可见性算法的非常重要部分，分为两类</p><ul><li>insert undo log：事务在插入新纪录产生的undo log，当事务提交后可以直接丢弃</li><li>update undo log：事务在进行update或delete的时候产生的undo log，在快照读的时候还是需要的，所以不能直接删除，只有当系统没有比这个log更早的read view的时候才能删除。所以长事务会产生很多老的视图导致undo log无法删除，占用大量存储空间。</li></ul><h4 id="read-view-读视图"><a href="#read-view-读视图" class="headerlink" title="read view 读视图"></a>read view 读视图</h4><p>读视图，是MySQL秒级创建视图的必要条件，比如一个事务在进行select操作（快照读）的时候会创建一个read view，这个read view其实只是三个字段：</p><ul><li>active_trx_id：read view生成时刻系统中正在活跃的事务ID</li><li>up_limit_id：active_trx_id中最小的事务ID</li><li>low_limit_id：active_trx_id中最大事务ID+1</li></ul><h4 id="可见性算法"><a href="#可见性算法" class="headerlink" title="可见性算法"></a>可见性算法</h4><p> 主要思路：当生成read-view的时候如何去拿获取的行记录中的 DB_TRX_ID 去和 read-view 中的三个属性(上面讲了)去作比较：</p><ul><li>首先比较这条记录的 DB_TRX_ID 是否是 小于 up_limit_id 或者 等于当前事务id。如果满足，那么说明当前事务能看到这条记录。如果大于则进入下一轮判断</li><li>然后判断这条记录的 DB_TRX_ID 是否 大于等于 low_limit_id。如果大于等于则说明此事务无法看见该条记录，不然就进入下一轮判断。</li><li>判断该条记录的 DB_TRX_ID 是否在活跃事务的数组中，如果在则说明这条记录还未提交对于当前操作的事务是不可见的，如果不在则说明已经提交，那么就是可见的</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;MVCC（Multiversion Concurrency Control）多版本并发控制，通过一种可见性算法来实现数据库并发控制。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://codeman.club/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://codeman.club/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用技巧（持续更新）</title>
    <link href="https://codeman.club/mac/use_tips/"/>
    <id>https://codeman.club/mac/use_tips/</id>
    <published>2020-09-25T12:36:30.000Z</published>
    <updated>2022-11-07T02:51:04.587Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、vim中鼠标滚动"><a href="#一、vim中鼠标滚动" class="headerlink" title="一、vim中鼠标滚动"></a>一、vim中鼠标滚动</h4><span id="more"></span><h5 id="1-Iterm2中设置（有弊端）"><a href="#1-Iterm2中设置（有弊端）" class="headerlink" title="1.Iterm2中设置（有弊端）"></a>1.Iterm2中设置（有弊端）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">iterm2-&gt;</span><span class="language-bash">Profiles-&gt;advanced</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜索mouse</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置up down 设置的值要符合vim的操作命令(vim编辑中j为光标向下移动，k为向上移动)</span></span><br><span class="line">Scorll whell down sends the specified text when in alternate screen mode. 设置为/j</span><br><span class="line">Scorll whell up sends the specified text when in alternate screen mode. 设置为/k</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此设置有个弊端就是，vim在编辑模式，上下滚动鼠标会输入j/k</span></span><br></pre></td></tr></table></figure><h5 id="2-x2F-vimrc文件中设置-建议"><a href="#2-x2F-vimrc文件中设置-建议" class="headerlink" title="2.~&#x2F;.vimrc文件中设置(建议)"></a>2.~&#x2F;.vimrc文件中设置(建议)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加配置</span></span><br><span class="line">set mouse=a</span><br></pre></td></tr></table></figure><h5 id="3-pecl安装swoole问题"><a href="#3-pecl安装swoole问题" class="headerlink" title="3.pecl安装swoole问题"></a>3.pecl安装swoole问题</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以通过--with-openssl-dir指定openssl位置</span></span><br><span class="line">enable sockets supports? [no] : yes</span><br><span class="line">enable openssl support? [no] : yes --with-openssl-dir=/usr/local/Cellar/openssl@1.1/1.1.1q</span><br></pre></td></tr></table></figure><h5 id="4-phpstorm安装swoole插件"><a href="#4-phpstorm安装swoole插件" class="headerlink" title="4.phpstorm安装swoole插件"></a>4.phpstorm安装swoole插件</h5><p><img src="/load_images/mac_use1.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;一、vim中鼠标滚动&quot;&gt;&lt;a href=&quot;#一、vim中鼠标滚动&quot; class=&quot;headerlink&quot; title=&quot;一、vim中鼠标滚动&quot;&gt;&lt;/a&gt;一、vim中鼠标滚动&lt;/h4&gt;</summary>
    
    
    
    <category term="Mac" scheme="https://codeman.club/categories/Mac/"/>
    
    
    <category term="Mac" scheme="https://codeman.club/tags/Mac/"/>
    
  </entry>
  
</feed>
